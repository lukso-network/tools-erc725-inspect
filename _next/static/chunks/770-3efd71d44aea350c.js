(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[770],{34063:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DEFAULT_GAS_VALUE=t.COMPACT_BYTES_ARRAY_STRING=t.LSP6_ALL_PERMISSIONS=t.LSP6_DEFAULT_PERMISSIONS=t.HASH_METHODS=t.SUPPORTED_VERIFICATION_METHODS_LIST=t.SUPPORTED_VERIFICATION_METHOD_HASHES=t.SUPPORTED_VERIFICATION_METHOD_STRINGS=t.NONE_VERIFICATION_METHOD=t.METHODS=t.ERC725_VERSION=t.ERC725Y_INTERFACE_IDS=void 0;const r=n(18269),a=n(22751),o=n(86386);var c,i;function s(e){if(null===e)return(0,r.keccak256)("");if(e instanceof Uint8Array){const t=(0,a.bufferToHex)((0,a.arrToBufArr)(e));return(0,r.keccak256)(t)}if("object"===typeof e){const t=JSON.stringify(e);return(0,r.keccak256)(t)}return(0,r.keccak256)(e)}t.ERC725Y_INTERFACE_IDS={legacy:"0x2bd57b73","2.0":"0x5a988c0f","3.0":"0x714df77c","5.0":"0x629aa694"},function(e){e.NOT_ERC725="NOT_ERC725",e.ERC725_LEGACY="ERC725_LEGACY",e.ERC725_v2="ERC725_v2",e.ERC725_v5="ERC725_v5"}(t.ERC725_VERSION||(t.ERC725_VERSION={})),t.METHODS={[o.Method.GET_DATA_LEGACY]:{sig:"0x54f6127f",value:(0,r.numberToHex)(0),returnEncoding:o.Encoding.BYTES},[o.Method.GET_DATA]:{sig:"0x4e3e6e9c",value:(0,r.numberToHex)(0),returnEncoding:o.Encoding.BYTES_ARRAY},[o.Method.GET_DATA_BATCH]:{sig:"0xdedff9c6",value:(0,r.numberToHex)(0),returnEncoding:o.Encoding.BYTES_ARRAY},[o.Method.OWNER]:{sig:"0x8da5cb5b",value:(0,r.numberToHex)(0),returnEncoding:o.Encoding.ADDRESS},[o.Method.SUPPORTS_INTERFACE]:{sig:"0x01ffc9a7",value:(0,r.numberToHex)(0),returnEncoding:o.Encoding.BOOL},[o.Method.IS_VALID_SIGNATURE]:{sig:"0x1626ba7e",value:(0,r.numberToHex)(0),returnEncoding:o.Encoding.BYTES4}},t.NONE_VERIFICATION_METHOD="0x00000000",function(e){e.KECCAK256_UTF8="keccak256(utf8)",e.KECCAK256_BYTES="keccak256(bytes)"}(c=t.SUPPORTED_VERIFICATION_METHOD_STRINGS||(t.SUPPORTED_VERIFICATION_METHOD_STRINGS={})),function(e){e.HASH_KECCAK256_UTF8="0x6f357c6a",e.HASH_KECCAK256_BYTES="0x8019f9b1"}(i=t.SUPPORTED_VERIFICATION_METHOD_HASHES||(t.SUPPORTED_VERIFICATION_METHOD_HASHES={})),t.SUPPORTED_VERIFICATION_METHODS_LIST=Object.values(c);const d={method:s,name:c.KECCAK256_UTF8,sig:i.HASH_KECCAK256_UTF8},u={method:s,name:c.KECCAK256_BYTES,sig:i.HASH_KECCAK256_BYTES};t.HASH_METHODS={[c.KECCAK256_UTF8]:d,[i.HASH_KECCAK256_UTF8]:d,[c.KECCAK256_BYTES]:u,[i.HASH_KECCAK256_BYTES]:u},t.LSP6_DEFAULT_PERMISSIONS={CHANGEOWNER:"0x0000000000000000000000000000000000000000000000000000000000000001",ADDCONTROLLER:"0x0000000000000000000000000000000000000000000000000000000000000002",EDITPERMISSIONS:"0x0000000000000000000000000000000000000000000000000000000000000004",ADDEXTENSIONS:"0x0000000000000000000000000000000000000000000000000000000000000008",CHANGEEXTENSIONS:"0x0000000000000000000000000000000000000000000000000000000000000010",ADDUNIVERSALRECEIVERDELEGATE:"0x0000000000000000000000000000000000000000000000000000000000000020",CHANGEUNIVERSALRECEIVERDELEGATE:"0x0000000000000000000000000000000000000000000000000000000000000040",REENTRANCY:"0x0000000000000000000000000000000000000000000000000000000000000080",SUPER_TRANSFERVALUE:"0x0000000000000000000000000000000000000000000000000000000000000100",TRANSFERVALUE:"0x0000000000000000000000000000000000000000000000000000000000000200",SUPER_CALL:"0x0000000000000000000000000000000000000000000000000000000000000400",CALL:"0x0000000000000000000000000000000000000000000000000000000000000800",SUPER_STATICCALL:"0x0000000000000000000000000000000000000000000000000000000000001000",STATICCALL:"0x0000000000000000000000000000000000000000000000000000000000002000",SUPER_DELEGATECALL:"0x0000000000000000000000000000000000000000000000000000000000004000",DELEGATECALL:"0x0000000000000000000000000000000000000000000000000000000000008000",DEPLOY:"0x0000000000000000000000000000000000000000000000000000000000010000",SUPER_SETDATA:"0x0000000000000000000000000000000000000000000000000000000000020000",SETDATA:"0x0000000000000000000000000000000000000000000000000000000000040000",ENCRYPT:"0x0000000000000000000000000000000000000000000000000000000000080000",DECRYPT:"0x0000000000000000000000000000000000000000000000000000000000100000",SIGN:"0x0000000000000000000000000000000000000000000000000000000000200000",EXECUTE_RELAY_CALL:"0x0000000000000000000000000000000000000000000000000000000000400000",ERC4337_PERMISSION:"0x0000000000000000000000000000000000000000000000000000000000800000",ALL_PERMISSIONS:"0x00000000000000000000000000000000000000000000000000000000007f3f7f"},t.LSP6_ALL_PERMISSIONS="0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",t.COMPACT_BYTES_ARRAY_STRING="[CompactBytesArray]",t.DEFAULT_GAS_VALUE=1e6},83485:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.decodeData=t.decodeKey=t.decodeTupleKeyValue=t.isValidTuple=void 0;const r=n(18269),a=n(34063),o=n(24025),c=n(1922),i=n(54748),s=n(80669),d=n(60047),u=/bytes(\d+)/,f=/Bytes(\d+)/,l=e=>!(e.length<=2)&&("("===e[0]||")"===e[e.length-1]),y=e=>e.substring(1,e.length-1).split(",");t.isValidTuple=(e,t)=>{if(!l(e)||!l(t))return!1;const n=e.replace(a.COMPACT_BYTES_ARRAY_STRING,""),c=y(n),s=y(t);if(c.length!==s.length)throw new Error(`Invalid tuple for valueType: ${e} / valueContent: ${t}. They should have the same number of elements. Got: ${c.length} and ${s.length}`);for(let a=0;a<c.length;a++){if(!(0,o.isValidValueType)(c[a]))throw new Error(`Invalid tuple for valueType: ${e} / valueContent: ${t}. Type: ${c[a]} is not valid. Valid types are: ${o.ALL_VALUE_TYPES}`);const n=c[a].split("bytes")[1];if(c[a].match(u)&&s[a].match(f)){if(n>s[a].slice(5))throw new Error(`Invalid tuple (${e},${t}: ${e[a]} cannot fit in ${t[a]}`)}if("unknown"===(0,i.valueContentEncodingMap)(s[a]).type&&"Bytes"!==s[a].slice(0,5)&&"0x"!==s[a].slice(0,2))throw new Error(`Invalid tuple for valueType: ${e} / valueContent: ${t}. valueContent of type: ${s[a]} is not valid`);if((0,r.isHexStrict)(s[a])){const r=s[a].length-2;if(Number.parseInt(n,10)<r)throw new Error(`Invalid tuple (${e},${t}: ${t[a]} cannot fit in ${e[a]}`)}else if(s[a].startsWith("0x"))throw new Error(`Invalid tuple for valueType: ${e} / valueContent: ${t}. valueContent of type: ${s[a]} is not a valid hex value`)}return!0};function b(e,n){switch(e.keyType.toLowerCase()){case"array":{if(!n||"0x"===n)return[];if("string"===typeof n&&16===(0,d.countNumberOfBytes)(n))return(0,d.decodeKeyValue)("Number","uint128",n,e.name)||0;const t=n.find((t=>t.key===e.key));if(!t)return[];const r=(0,d.decodeKeyValue)("Number","uint128",t.value,e.name)||0,a=[];for(let o=0;o<r;o++){const t=n.find((t=>t.key===(0,d.encodeArrayKey)(e.key,o)));t&&a.push((0,d.decodeKeyValue)(e.valueContent,e.valueType,t.value,e.name))}return a}case"mappingwithgrouping":case"singleton":case"mapping":if(Array.isArray(n)){const t=n.find((t=>t.key===e.key));return t?(0,d.decodeKeyValue)(e.valueContent,e.valueType,t.value,e.name):null}if(e.valueType.includes(a.COMPACT_BYTES_ARRAY_STRING)){const r=e.valueType.replace(a.COMPACT_BYTES_ARRAY_STRING,""),o=e.valueContent.replace(a.COMPACT_BYTES_ARRAY_STRING,"");if("("===r[0]&&")"===r[r.length-1]){return(0,i.decodeValueType)("bytes[CompactBytesArray]",n).map((e=>(0,t.decodeTupleKeyValue)(o,r,e)))}return(0,i.decodeValueType)(e.valueType,n)}return(0,t.isValidTuple)(e.valueType,e.valueContent)?(0,t.decodeTupleKeyValue)(e.valueContent,e.valueType,n):(0,d.decodeKeyValue)(e.valueContent,e.valueType,n,e.name);default:return console.error(`Incorrect data match or keyType in schema from decodeKey(): "${e.keyType}"`),null}}t.decodeTupleKeyValue=(e,t,n)=>{const r=t.replace(a.COMPACT_BYTES_ARRAY_STRING,""),o=y(r),c=y(e),i=[];o.forEach((e=>{const t=e.match(u);t&&i.push(Number.parseInt(t[1],10));const n=e.match(/u?int(\d+)/);n&&i.push(Number.parseInt(n[1],10)/8),"address"===e&&i.push(20)}));const s=i.reduce(((e,t)=>e+t),0);if(n.length!==2+2*s)return console.error(`Trying to decode a value: ${n} which does not match the length of the valueType: ${t}. Expected ${s} bytes.`),[];let f=2;const l=i.map((e=>{const t=n.substring(f,f+2*e);return f+=2*e,`0x${t}`}));return c.map(((e,t)=>(0,d.decodeKeyValue)(e,o[t],l[t])))},t.decodeKey=b,t.decodeData=function(e,t){const n=({keyName:e,dynamicKeyParts:n,value:r},a=!0)=>{const o=(0,c.isDynamicKeyName)(e)?(0,s.getSchemaElement)(t,e,n):(0,s.getSchemaElement)(t,e);let i=null;try{i=b(o,r)}catch(d){if(a)throw d;console.error(d)}return{key:o.key,name:o.name,value:i}};return Array.isArray(e)?e.map((e=>n(e,!1))):n(e)}},1922:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.generateDynamicKeyName=t.encodeKeyName=t.isDynamicKeyName=t.encodeDynamicKeyPart=t.dynamicTypesRegex=void 0;const r=n(18269),a=n(60047),o=["<string>","<address>","<bool>"];t.dynamicTypesRegex=/<(uint|int|bytes)(\d+)>/;function c(e){const n=e.split(":");for(let r=0;r<n.length;r++)if(o.includes(n[r])||n[r].match(t.dynamicTypesRegex))return!0;return!1}t.encodeDynamicKeyPart=(e,n,a)=>{let c="",i=0;if(o.includes(e))c=e.slice(1,-1);else{const n=e.match(t.dynamicTypesRegex);if(!n)throw new Error(`Dynamic key: ${e} is not supported`);c=n[1],i=Number.parseInt(n[2],10)}switch(c){case"string":return(0,r.keccak256)(n).slice(2,2+2*a);case"bool":if("true"!==n&&"false"!==n)throw new Error(`Wrong value: ${n} for dynamic key with type: <bool>. Expected "true" or "false".`);return(0,r.leftPad)(+("true"===n),2*a).slice(2);case"address":if(!(0,r.isAddress)(n))throw new Error(`Wrong value: ${n} for dynamic key with type: <address>. Value is not an address.`);return a>20?(0,r.leftPad)(n.replace("0x",""),2*a).toLowerCase():n.replace("0x","").slice(0,2*a).toLowerCase();case"uint":{if(i>256||i%8!==0)throw new Error(`Wrong dynamic key type: ${e}. 0 < M <= 256, M % 8 == 0. Got: ${i}.`);const t=(0,r.numberToHex)(n).slice(2);return t.length<=2*a?(0,r.padLeft)(t,2*a):t.slice(2*-a)}case"int":throw new Error("The encoding of <intM> has not been implemented yet.");case"bytes":{const t=n.replace("0x","");if(t.length!==2*i)throw new Error(`Wrong value: ${n} for dynamic key with type: ${e}. Value is not ${i} bytes long.`);if(!(0,r.isHex)(t))throw new Error(`Wrong value: ${n} for dynamic key with type: ${e}. Value is not in hex.`);return t.length>2*a?t.slice(0,2*a):(0,r.leftPad)(t,2*a).toLowerCase()}default:throw new Error(`Dynamic key: ${e} is not supported`)}},t.isDynamicKeyName=c;const i=(e,n)=>{if(1!==n.length)throw new Error(`Dynamic key of type: Mapping expects exactly 1 variable. Got: ${n.length} (${n})`);const a=e.split(":");return`${(0,r.keccak256)(a[0]).slice(0,22)}0000${(0,t.encodeDynamicKeyPart)(a[1],n[0],20)}`},s=(e,n)=>{const a=e.split(":");let o=0;if(c(a[1])&&(o+=1),c(a[2])&&(o+=1),o!==n.length)throw new Error(`Can not encode dynamic key of type: MappingWithGrouping. Wrong number of arguments. Expects exactly ${o} variable(s), got: ${n.length} (${n})`);const i=(0,r.keccak256)(a[0]).slice(0,14);let s="";s=c(a[1])?(0,t.encodeDynamicKeyPart)(a[1],n[0],4):(0,r.keccak256)(a[1]).slice(2,10);let d="";return d=c(a[2])?(0,t.encodeDynamicKeyPart)(a[2],n[n.length-1],20):(0,r.keccak256)(a[2]).slice(2,42),`${i}${s}0000${d}`};t.encodeKeyName=function(e,t){if(c(e))return function(e,t){if(!t)throw new Error(`Can't encode dynamic key name: ${e} without dynamicKeyParts`);const n="string"===typeof t?[t]:t,r=(0,a.guessKeyTypeFromKeyName)(e);switch(r){case"Mapping":return i(e,n);case"MappingWithGrouping":return s(e,n);default:throw new Error(`Could not encode dynamic key: ${e} of type: ${r}`)}}(e,t);switch((0,a.guessKeyTypeFromKeyName)(e)){case"MappingWithGrouping":{const t=e.split(":");return s(`${t[0]}:<string>:<address>`,[t[1],t[2]])}case"Mapping":{const t=e.split(":");return(0,r.isAddress)(t[1])?i(`${t[0]}:<address>`,[t[1]]):i(`${t[0]}:<string>`,[t[1]])}case"Array":return t&&"number"===typeof t?(0,a.encodeArrayKey)((0,r.keccak256)(e),t):(0,r.keccak256)(e);default:return(0,r.keccak256)(e)}};t.generateDynamicKeyName=(e,t)=>{let n=0;const a="string"===typeof t?[t]:t;return e.split(":").map((t=>{if(!c(t))return t;if(!a[n])throw new Error(`Can not generate key name: ${e}. Missing/not enough dynamicKeyParts: ${a}`);const o=a[n];if("<address>"===t&&!(0,r.isAddress)(o))throw new Error(`Dynamic key is expecting an <address> but got: ${o}`);return n+=1,o.replace("0x","")})).join(":")}},54748:function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeValueContent=t.encodeValueContent=t.decodeValueType=t.encodeValueType=t.valueContentEncodingMap=t.decodeDataSourceWithHash=t.encodeDataSourceWithHash=void 0;const a=r(n(93338)),o=n(18269),c=n(34063),i=n(60047),s=a.default,d=/^uint(\d+)$/,u=/^bytes(\d+)$/,f=/Bytes(\d+)/;t.encodeDataSourceWithHash=(e,t)=>{const n=(0,i.getVerificationMethod)((null===e||void 0===e?void 0:e.method)||c.NONE_VERIFICATION_METHOD);return["0x0000",(0,o.stripHexPrefix)(n?(0,o.padLeft)((0,o.keccak256)(n.name).slice(0,10),8):"00000000"),(0,o.stripHexPrefix)((null===e||void 0===e?void 0:e.data)?(0,o.padLeft)(e.data.slice(2).length/2,4):"0000"),(0,o.stripHexPrefix)((null===e||void 0===e?void 0:e.data)?(0,o.stripHexPrefix)(null===e||void 0===e?void 0:e.data):""),(0,o.stripHexPrefix)((0,o.utf8ToHex)(t))].join("")};t.decodeDataSourceWithHash=e=>{if("0x0000"===e.slice(0,6)){const t=`0x${e.slice(6,14)}`,n=(0,i.getVerificationMethod)(t),r=`0x${e.slice(14,18)}`,a=(0,o.hexToNumber)(r,!1),c=`0x${e.slice(18,18+2*a)}`,s=(0,o.hexToUtf8)(`0x${e.slice(18+2*a)}`);return{verification:{method:(null===n||void 0===n?void 0:n.name)||t,data:c},url:s}}const t=e.slice(0,10),n=(0,i.getVerificationMethod)(t),r=e.slice(10);try{const e=(0,o.hexToUtf8)(`0x${r}`);if(r.length<64||/^[a-z]{2,}:[/\S]/.test(e))return{verification:{method:c.NONE_VERIFICATION_METHOD,data:"0x"},url:e}}catch(d){}const a=`0x${r.slice(0,64)}`,s=(0,o.hexToUtf8)(`0x${r.slice(64)}`);return{verification:{method:(null===n||void 0===n?void 0:n.name)||t,data:a},url:s}};const l=e=>e.filter(((e,t)=>{if(!(0,o.isHex)(e))throw new Error(`Couldn't encode bytes[CompactBytesArray], value at index ${t} is not hex`);if(e.length>131072)throw new Error(`Couldn't encode bytes[CompactBytesArray], value at index ${t} exceeds 65_535 bytes`);return!0})).reduce(((e,t)=>{const n=(0,o.stripHexPrefix)(t).length/2,r=(0,o.padLeft)((0,o.numberToHex)(n),4);return e+(0,o.stripHexPrefix)(r)+(0,o.stripHexPrefix)(t)}),"0x"),y=e=>{if(!(0,o.isHex)(e))throw new Error("Couldn't decode, value is not hex");let t=0;const n=[],r=(0,o.stripHexPrefix)(e);for(;t<r.length;){const e=Number((0,o.hexToNumber)(`0x${r.slice(t,t+4)}`));0===e?n.push(""):n.push(`0x${r.slice(t+4,t+2*(e+2))}`),t+=2*(e+2)}if(t>r.length)throw new Error("Couldn't decode bytes[CompactBytesArray]");return n},b=(e,t)=>{const n=y(e);return n.forEach(((e,n)=>{if((0,o.stripHexPrefix)(e).length>2*t)throw new Error(`Hex bytes${t} value at index ${n} does not fit in ${t} bytes`)})),n},p=(e,t)=>{const n=e.map(((e,n)=>{const r=(0,o.stripHexPrefix)((0,o.numberToHex)(e)).padStart(2*t,"0");if(r.length>2*t)throw new Error(`Hex uint${8*t} value at index ${n} does not fit in ${t} bytes`);return r}));return l(n)},h=e=>{const t=e.map((e=>(0,o.utf8ToHex)(e)));return l(t)},m=e=>y(e).map((e=>(0,o.hexToUtf8)(e))),E=e=>{const t=e.match(d),n=e.match(u),r=n?Number.parseInt(n[1],10):"",a=t?Number.parseInt(t[0].slice(4),10):"";if(e.includes("[CompactBytesArray]")){return Object.assign(Object.assign({"bytes[CompactBytesArray]":{encode:e=>l(e),decode:e=>y(e)},"string[CompactBytesArray]":{encode:e=>h(e),decode:e=>m(e)}},(()=>{const e={};for(let t=1;t<33;t++)e[`bytes${t}[CompactBytesArray]`]={encode:e=>{return r=t,(n=e).forEach(((e,t)=>{if((0,o.stripHexPrefix)(e).length>2*r)throw new Error(`Hex bytes${r} value at index ${t} does not fit in ${r} bytes`)})),l(n);var n,r},decode:e=>b(e,t)};return e})()),(()=>{const e={};for(let t=1;t<33;t++)e[`uint${8*t}[CompactBytesArray]`]={encode:e=>p(e,t),decode:e=>{return n=t,y(e).map(((e,t)=>{if((0,o.stripHexPrefix)(e).length>2*n)throw new Error(`Hex uint${8*n} value at index ${t} does not fit in ${n} bytes`);return Number((0,o.hexToNumber)(e))}));var n}};return e})())[e]}if("bytes"===e)return{encode:e=>(0,o.toHex)(e),decode:e=>e};switch(e){case"bool":case"boolean":return{encode:e=>e?"0x01":"0x00",decode:e=>"0x01"===e};case"string":return{encode:e=>"number"===typeof e?(0,o.utf8ToHex)(`${e}`):(0,o.utf8ToHex)(e),decode:e=>(0,o.hexToUtf8)(e)};case"address":return{encode:e=>{const t=s.encodeParameter("address",e),n=(0,o.hexToBytes)(t);return(0,o.bytesToHex)(n.slice(12))},decode:e=>(0,o.toChecksumAddress)(e)};case`uint${a}`:return{encode:t=>{if(!(0,i.isValidUintSize)(a))throw new Error(`Can't encode ${t} as ${e}. Invalid \`uintN\` provided. Expected a multiple of 8 bits between 8 and 256.`);const n=s.encodeParameter(e,t),r=(0,i.countSignificantBits)(n);if(r>a)throw new Error(`Can't represent value ${t} as ${e}. To many bits required ${r} > ${a}`);const c=(0,o.hexToBytes)(n),d=32-a/8;return(0,o.bytesToHex)(c.slice(d))},decode:t=>{if(!(0,o.isHex)(t))throw new Error(`Can't convert ${t} to ${e}, value is not hex.`);if(!(0,i.isValidUintSize)(a))throw new Error(`Can't decode ${t} as ${e}. Invalid \`uintN\` provided. Expected a multiple of 8 bits between 8 and 256.`);const n=(0,i.countSignificantBits)(t);if(n>a)throw new Error(`Can't represent value ${t} as ${e}. To many bits required ${n} > ${a}`);const r=(0,i.countNumberOfBytes)(t);return r>a/8&&console.debug(`Value ${t} for ${e} is too long but value contains only ${n}. Too many bytes. ${r} > 16`),(0,o.toBN)(t).toNumber()}};case`bytes${r}`:return{encode:t=>{if(!(0,i.isValidByteSize)(r))throw new Error(`Can't encode ${t} as ${e}. Invalid \`bytesN\` provided. Expected a \`N\` value for bytesN between 1 and 32.`);return((e,t)=>{const n=Number.parseInt(e.split("bytes")[1],10);let r;r="string"!==typeof t||(0,o.isHex)(t)?"number"===typeof t?(0,o.padLeft)((0,o.numberToHex)(t),2*n):t:(0,o.toHex)(t);const a=(0,i.countNumberOfBytes)(r);if(a>n)throw new Error(`Can't convert ${t} to ${e}. Too many bytes, expected at most ${n} bytes, received ${a}.`);const c=s.encodeParameter(e,r);if(32===n)return c;const d=(0,o.hexToBytes)(c);return(0,o.bytesToHex)(d.slice(0,n))})(e,t)},decode:t=>{const n=s.encodeParameter(e,t);return s.decodeParameter(e,n)}};case"bool[]":case"boolean[]":return{encode:e=>s.encodeParameter("bool[]",e),decode:e=>s.decodeParameter("bool[]",e)};case"string[]":return{encode:e=>s.encodeParameter("string[]",e),decode:e=>s.decodeParameter("string[]",e)};case"address[]":return{encode:e=>s.encodeParameter("address[]",e),decode:e=>s.decodeParameter("address[]",e)};case"uint256[]":return{encode:e=>s.encodeParameter("uint256[]",e),decode:e=>s.decodeParameter("uint256[]",e).map((e=>Number.parseInt(e,10)))};case"bytes32[]":return{encode:e=>s.encodeParameter("bytes32[]",e),decode:e=>s.decodeParameter("bytes32[]",e)};case"bytes4[]":return{encode:e=>s.encodeParameter("bytes4[]",e),decode:e=>s.decodeParameter("bytes4[]",e)};case"bytes[]":return{encode:e=>s.encodeParameter("bytes[]",e),decode:e=>s.decodeParameter("bytes[]",e)};case"bytes[CompactBytesArray]":return{encode:e=>l(e),decode:e=>y(e)};case"string[CompactBytesArray]":return{encode:e=>h(e),decode:e=>m(e)};default:return{encode:t=>{throw new Error(`Could not encode ${t}. Value type ${e} is unknown`)},decode:t=>{throw new Error(`Could not decode ${t}. Value type ${e} is unknown`)}}}};t.valueContentEncodingMap=e=>{const n=e.match(f),r=n?Number.parseInt(n[1],10):"";switch(e){case"Keccak256":return{type:"bytes32",encode:e=>e,decode:e=>e};case"Number":return{type:"uint256",encode:e=>{let t;try{t=Number.parseInt(e,10)}catch(n){throw new Error(n)}return(0,o.padLeft)((0,o.numberToHex)(t),64)},decode:e=>Number((0,o.hexToNumber)(e))};case"Address":return{type:"address",encode:e=>{if((0,o.isAddress)(e))return e.toLowerCase();throw new Error(`Address: "${e}" is an invalid address.`)},decode:e=>(0,o.toChecksumAddress)(e)};case"String":case"Markdown":case"URL":return{type:"string",encode:e=>(0,o.utf8ToHex)(e),decode:e=>(0,o.hexToUtf8)(e)};case"AssetURL":case"JSONURL":case"VerifiableURI":return{type:"custom",encode:e=>{const{verification:{data:n,method:r}={},json:a,url:o}=e;let s=n;if(a){if(r)throw new Error('When passing in the `json` property, we use "keccak256(utf8)" as a default verification method. You do not need to set a `verification.method`.');s=(0,i.hashData)(a,c.SUPPORTED_VERIFICATION_METHOD_STRINGS.KECCAK256_UTF8)}if(!s)throw new Error("You have to provide either the verification.data or the json via the respective properties");return(0,t.encodeDataSourceWithHash)({method:r||c.SUPPORTED_VERIFICATION_METHOD_STRINGS.KECCAK256_UTF8,data:s||"0x"},o)},decode:e=>(0,t.decodeDataSourceWithHash)(e)};case`Bytes${r}`:return{type:"bytes",encode:t=>{if("string"!==typeof t||!(0,o.isHex)(t))throw new Error(`Value: ${t} is not hex.`);if(r&&!(0,i.isValidByteSize)(r))throw new Error(`Provided bytes length: ${r} for encoding valueContent: ${e} is not valid.`);if(r&&t.length!==2+2*r)throw new Error(`Value: ${t} is not of type ${e}. Expected hex value of length ${2+2*r}`);return t},decode:t=>"string"===typeof t&&(0,o.isHex)(t)?r&&!(0,i.isValidByteSize)(r)?(console.error(`Provided bytes length: ${r} for encoding valueContent: ${e} is not valid.`),null):r&&t.length!==2+2*r?(console.error(`Value: ${t} is not of type ${e}. Expected hex value of length ${2+2*r}`),null):t:(console.error(`Value: ${t} is not hex.`),null)};case"BitArray":return{type:"bytes",encode:e=>{if("string"!==typeof e||!(0,o.isHex)(e))throw new Error(`Value: ${e} is not hex.`);return e},decode:e=>"string"===typeof e&&(0,o.isHex)(e)?e:(console.error(`Value: ${e} is not hex.`),null)};case"Boolean":return{type:"bool",encode:e=>E("bool").encode(e),decode:e=>{try{return E("bool").decode(e)}catch(t){throw new Error(`Value ${e} is not a boolean`)}}};default:return{type:"unknown",encode:t=>{throw new Error(`Could not encode unknown (${e}) valueContent.`)},decode:t=>{throw new Error(`Could not decode unknown (${e}) valueContent.`)}}}},t.encodeValueType=function(e,t){return"undefined"===typeof t||null===t?t:E(e).encode(t)},t.decodeValueType=function(e,t){return"0x"===t?null:"undefined"===typeof t||null===t?t:E(e).decode(t)},t.encodeValueContent=function(e,n){if("0x"===e.slice(0,2))return e===n&&n;const r=(0,t.valueContentEncodingMap)(e);if(!r)throw new Error(`Could not encode valueContent: ${e}.`);if(null===n||void 0===n)return"0x";if(("AssetURL"===e||"JSONURL"===e||"Boolean"===e)&&"string"===typeof n){throw new Error(`Could not encode valueContent: ${e} with value: ${n}. Expected ${"Boolean"===e?"boolean":"object"}.`)}return r.encode(n)},t.decodeValueContent=function(e,n){if((0,i.isValueContentLiteralHex)(e)){if(e.toLowerCase()!==n)throw new Error(`Could not decode value content: the value ${n} does not match the Hex Literal ${e} defined in the \`valueContent\` part of the schema`);return e}return null==n||"0x"===n?null:(0,t.valueContentEncodingMap)(e).decode(n)}},80669:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getSchemaElement=void 0;const r=n(18269),a=n(1922);t.getSchemaElement=function(e,t,n){let o;if((0,a.isDynamicKeyName)(t)){if(!n)throw new Error(`Can't getSchemaElement for dynamic key: ${t} without dynamicKeyParts.`);return((e,t,n)=>{const r=e.find((e=>e.name===t));if(!r)throw new Error(`No matching schema found for dynamic key: ${t}`);const o=(0,a.encodeKeyName)(t,n),c=(0,a.generateDynamicKeyName)(t,n);return Object.assign(Object.assign({},r),{key:o,name:c})})(e,t,n)}o=(0,r.isHex)(t)?(0,r.isHexStrict)(t)?t:`0x${t}`:(0,a.encodeKeyName)(t);const c=e.find((e=>e.key===o));if(!c)throw new Error(`No matching schema found for key: ${t} (${o}).`);return c}},60047:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isValueContentLiteralHex=t.isValidByteSize=t.isValidUintSize=t.duplicateMultiTypeERC725SchemaEntry=t.splitMultiDynamicKeyNamePart=t.countSignificantBits=t.countNumberOfBytes=t.patchIPFSUrlsIfApplicable=t.generateSchemasFromDynamicKeys=t.convertIPFSGatewayUrl=t.isDataAuthentic=t.hashData=t.getVerificationMethod=t.encodeData=t.decodeKeyValue=t.encodeKey=t.encodeTupleKeyValue=t.guessKeyTypeFromKeyName=t.encodeArrayKey=t.encodeKeyValue=void 0;const r=n(18269),a=n(34063),o=n(54748),c=n(1922),i=n(80669),s=n(83485);function d(e,t,n,r){if(!(!!(0,o.valueContentEncodingMap)(e)||b(e)))throw new Error(`The valueContent '${e}' for ${r} is not supported.`);const a="[]"===t.slice(t.length-2);if((t.startsWith("uint")||t.startsWith("bytes"))&&"object"!==typeof n)return(0,o.encodeValueType)(t,n);if(!a&&!Array.isArray(n))return(0,o.encodeValueContent)(e,n);const c=(0,o.valueContentEncodingMap)(e),i=c&&c.type===t.split("[]")[0];let s;if(Array.isArray(n)){const t=[];for(let r=0;r<n.length;r++){const a=n[r];t.push((0,o.encodeValueContent)(e,a))}s=t}return"bytes"===t||i?a&&i&&(s=(0,o.encodeValueType)(t,n)):s=(0,o.encodeValueType)(t,s),s}function u(e,t){return e.slice(0,34)+(0,r.padLeft)((0,r.numberToHex)(t),32).replace("0x","")}t.encodeKeyValue=d,t.encodeArrayKey=u,t.guessKeyTypeFromKeyName=function(e){const t=e.split(":");return 3===t.length?"MappingWithGrouping":2===t.length?"Mapping":"[]"===e.substring(e.length-2,e.length)?"Array":"Singleton"};function f(e,n,r=0,c=(Array.isArray(n)?n.length:0)){switch(e.keyType.toLowerCase()){case"array":{if("number"===typeof n)return(0,o.encodeValueType)("uint128",n);if(!Array.isArray(n))return console.error("Can't encode a non array for key of type array"),null;if("number"!==typeof r||"number"!==typeof c)throw new Error("Invalid `startingIndex` or `totalArrayLength` parameters. Values must be of type number.");if(r<0)throw new Error("Invalid `startingIndex` parameter. Value cannot be negative.");if(c<n.length)throw new Error("Invalid `totalArrayLength` parameter. Array length must be at least as large as the number of elements of the value array.");const t=[];for(let a=0;a<n.length;a++){0===a&&t.push({key:e.key,value:(0,o.encodeValueType)("uint128",c)});const i=r+a,s=n[a];t.push({key:u(e.key,i),value:d(e.valueContent,e.valueType,s,e.name)})}return t}case"mappingwithgrouping":case"singleton":case"mapping":if((0,s.isValidTuple)(e.valueType,e.valueContent)){if(!Array.isArray(n))throw new Error(`Incorrect value for tuple. Got: ${n}, expected array.`);const r=e.valueType.includes(a.COMPACT_BYTES_ARRAY_STRING);if(Array.isArray(n[0])&&r){const r=e.valueType.replace(a.COMPACT_BYTES_ARRAY_STRING,""),c=e.valueContent.replace(a.COMPACT_BYTES_ARRAY_STRING,""),i=n.map((e=>(0,t.encodeTupleKeyValue)(c,r,e)));return(0,o.encodeValueType)("bytes[CompactBytesArray]",i)}return(0,t.encodeTupleKeyValue)(e.valueContent,e.valueType,n)}if(Array.isArray(n)&&Array.isArray(n[0])&&!(0,s.isValidTuple)(e.valueType,e.valueContent))throw new Error("Incorrect value for nested array: not a tuple.");return d(e.valueContent,e.valueType,n,e.name);default:return console.error(`Incorrect data match or keyType in schema from encodeKey(): "${e.keyType}"`),null}}function l(e){const t=Object.values(a.HASH_METHODS).find((({name:t,sig:n})=>t===e||n===e));if(!t&&"0x00000000"!==e)throw new Error(`Chosen verification method '${e}' is not supported. Supported verification methods: ${a.SUPPORTED_VERIFICATION_METHODS_LIST}`);return t}function y(e,t){var n;return(null===(n=l(t))||void 0===n?void 0:n.method(e))||(0,r.leftPad)(0,64)}t.encodeTupleKeyValue=(e,t,n)=>{const a=t.substring(1,t.length-1).split(","),o=e.substring(1,e.length-1).split(",");if(a.length!==n.length)throw new Error(`Can not encode tuple key value: ${n}. Expecte array of length: ${a.length}`);return`0x${o.map(((e,t)=>{const o=d(e,a[t],n[t]);return o?(0,r.stripHexPrefix)(o):""})).join("")}`},t.encodeKey=f,t.decodeKeyValue=function(e,t,n,a){const c=(0,o.valueContentEncodingMap)(e);let i=n;if(!c&&"0x"!==e.slice(0,2))throw new Error(`The valueContent "${e}" for "${a}" is not supported.`);let s=c&&c.type===t.split("[]")[0];const d="[]"===t.substring(t.length-2);if("bytes"===t.slice(0,5)&&"[]"!==t.slice(-2)||"string"===t||(0,r.isAddress)(i)||(i=(0,o.decodeValueType)(t,i)),s&&(0,r.isAddress)(i)&&!(0,r.checkAddressChecksum)(i)&&(s=!s),s&&"string"!==t)return i;if(d&&Array.isArray(i)){const t=[];for(let n=0;n<i.length;n++){const r=i[n];t.push((0,o.decodeValueContent)(e,r))}return t}return(0,o.decodeValueContent)(e,i)},t.encodeData=function(e,t){return(Array.isArray(e)?e:[e]).reduce(((e,{keyName:n,value:r,dynamicKeyParts:a,startingIndex:o,totalArrayLength:s})=>{let d,u=null;if((0,c.isDynamicKeyName)(n)){if(!a)throw new Error(`Can't encodeData for dynamic key: ${n} with non dynamic values. Got: ${r}, expected object.`);u=(0,i.getSchemaElement)(t,n,a),d=f(u,r,o,s)}else u=(0,i.getSchemaElement)(t,n),d=f(u,r,o,s);if("string"===typeof d)e.keys.push(u.key),e.values.push(d);else if(!1!==d&&null!=d)for(let t=0;t<d.length;t++){const{key:n,value:r}=d[t];e.keys.push(n),e.values.push(r)}return e}),{keys:[],values:[]})},t.getVerificationMethod=l,t.hashData=y,t.isDataAuthentic=function(e,t){if(!t||!t.method)return!0;const n=y(e,t.method);return n===t.data||(console.error(`Hash mismatch, returned JSON hash ("${n}") is different from expected hash: "${t.method}"`),!1)},t.convertIPFSGatewayUrl=function(e){let t=e;return e.endsWith("/")&&!e.endsWith("/ipfs/")?t=`${e}ipfs/`:e.endsWith("/ipfs")?t=`${e}/`:e.endsWith("/ipfs/")||(t=`${e}/ipfs/`),t};t.generateSchemasFromDynamicKeys=(e,t)=>e.map((e=>"string"===typeof e?(0,i.getSchemaElement)(t,e):(0,i.getSchemaElement)(t,e.keyName,e.dynamicKeyParts))),t.patchIPFSUrlsIfApplicable=function(e,t){var n;return-1!==(null===(n=null===e||void 0===e?void 0:e.url)||void 0===n?void 0:n.indexOf("ipfs://"))?Object.assign(Object.assign({},e),{url:e.url.replace("ipfs://",t)}):e},t.countNumberOfBytes=function(e){return(0,r.stripHexPrefix)(e).length/2},t.countSignificantBits=function(e){const t=(0,r.hexToBytes)(e);for(let n=0;n<t.length;n++)if(0!==t[n])return 8*(t.length-n-1)+(32-Math.clz32(t[n]));return 0};t.splitMultiDynamicKeyNamePart=e=>e.length<=1||"<"!==e.charAt(0)||">"!==e.slice(-1)?[e]:e.substring(1,e.length-1).split("|");function b(e){return(0,r.isHexStrict)(e)}t.duplicateMultiTypeERC725SchemaEntry=e=>{if(Array.isArray(e))throw new Error("Input schema should be a ERC725JSONSchema and not an array.");if(!("name"in e)||!("key"in e)||!("keyType"in e))throw new Error("Input schema object is missing 'name', 'key' and 'keyType' properties. Did you pass a valid ERC725JSONSchema object?");const n=e.keyType.toLowerCase();if("mapping"!==n&&"mappingwithgrouping"!==n)return[e];if(!e.name.includes("<")||!e.name.includes("|")||!e.name.includes(">"))return[e];if(-1===e.name.indexOf(":"))throw new Error(`Input schema type is Mapping or MappingWithGroups but the key: ${e.key} is not valid (missing ':').`);const r=e.name.split(":"),a=e.key.substring(0,e.key.indexOf("<")),o=Object.assign(Object.assign({},e),{name:r.shift(),key:a});if(1===r.length){return(0,t.splitMultiDynamicKeyNamePart)(r[0]).map((e=>Object.assign(Object.assign({},o),{name:`${o.name}:<${e}>`,key:`${o.key}<${e}>`})))}let c;if("<"!==r[0].charAt(0)||">"!==r[0].slice(-1))c=[Object.assign(Object.assign({},o),{name:`${o.name}:${r[0]}`,key:`${o.key}`})];else{c=(0,t.splitMultiDynamicKeyNamePart)(r[0]).map((e=>Object.assign(Object.assign({},o),{name:`${o.name}:<${e}>`,key:`${o.key}<${e}>`})))}const i=(0,t.splitMultiDynamicKeyNamePart)(r[1]);return c.flatMap((e=>i.map((t=>Object.assign(Object.assign({},e),{name:`${e.name}:<${t}>`,key:`${e.key}<${t}>`})))))},t.isValidUintSize=function(e){return e>=8&&e<=256&&e%8===0},t.isValidByteSize=function(e){return e>=1&&e<=32},t.isValueContentLiteralHex=b},24025:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isValidValueType=t.ALL_VALUE_TYPES=void 0,t.ALL_VALUE_TYPES=["uint8","uint16","uint24","uint32","uint40","uint48","uint56","uint64","uint72","uint80","uint88","uint96","uint104","uint112","uint120","uint128","uint136","uint144","uint152","uint160","uint168","uint176","uint184","uint192","uint200","uint208","uint216","uint224","uint232","uint240","uint248","uint256","int8","int16","int24","int32","int40","int48","int56","int64","int72","int80","int88","int96","int104","int112","int120","int128","int136","int144","int152","int160","int168","int176","int184","int192","int200","int208","int216","int224","int232","int240","int248","int256","bytes1","bytes2","bytes3","bytes4","bytes5","bytes6","bytes7","bytes8","bytes9","bytes10","bytes11","bytes12","bytes13","bytes14","bytes15","bytes16","bytes17","bytes18","bytes19","bytes20","bytes21","bytes22","bytes23","bytes24","bytes25","bytes26","bytes27","bytes28","bytes29","bytes30","bytes31","bytes32","bool","boolean","address","string","bytes","string[]","address[]","uint256[]","bytes32[]","bytes4[]","bytes[]","bool[]","boolean[]"],t.isValidValueType=function(e){return t.ALL_VALUE_TYPES.includes(e)}},86386:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Encoding=t.Method=void 0,function(e){e.GET_DATA_LEGACY="getDataLegacy",e.GET_DATA="getData",e.GET_DATA_BATCH="getDataBatch",e.OWNER="owner",e.SUPPORTS_INTERFACE="supportsInterface",e.IS_VALID_SIGNATURE="isValidSignature"}(t.Method||(t.Method={})),function(e){e.BYTES="bytes",e.BYTES4="bytes4",e.BOOL="bool",e.UINT256="uint256",e.BYTES32_ARRAY="bytes32[]",e.BYTES_ARRAY="bytes[]",e.ADDRESS="address"}(t.Encoding||(t.Encoding={}))},9008:function(e,t,n){e.exports=n(5443)},9068:function(e,t,n){"use strict";n.d(t,{Ac:function(){return a},Pc:function(){return r},xh:function(){return o}});const r="0xa918fa6b",a="0xcee78b40",o={LSP17ExtensionPrefix:"0xcee78b4094da860110960000"}},34387:function(e,t,n){"use strict";n.d(t,{_:function(){return a},i:function(){return r}});const r={key:"0xeafec4d89fa9619884b600005ef83ad9559033e6e941db7d7c495acdce616347",value:"0x5ef83ad9"},a={SupportedStandards_LSP3:r.key,LSP3Profile:"0x5ef83ad9559033e6e941db7d7c495acdce616347d28e90c7ce47cbfcfcad3bc5"}},46964:function(e,t,n){"use strict";n.d(t,{$Z:function(){return r},Oi:function(){return a},iQ:function(){return o}});const r={key:"0xeafec4d89fa9619884b60000a4d96624a38f7ac2d8d9a604ecf07c12c77e480c",value:"0xa4d96624"},a={SupportedStandards_LSP4:r.key,LSP4TokenName:"0xdeba1e292f8ba88238e10ab3c7f88bd4be4fac56cad5194b6ecceaf653468af1",LSP4TokenSymbol:"0x2f0a68ab07768e01943a599e73362a0e17a63a72e94dd2e384d2c1d4db932756",LSP4TokenType:"0xe0261fa95db2eb3b5439bd033cda66d56b96f92f243a8228fd87550ed7bdfdb3",LSP4Metadata:"0x9afb95cacc9f95858ec44aa8c3b685511002e30ae54415823f406128b85b238e",LSP4CreatorsMap:"0x6de85eaf5d982b4e5da00000","LSP4Creators[]":{length:"0x114bd03b3a46d48759680d81ebb2b414fda7d030a7105a851867accf1c2352e7",index:"0x114bd03b3a46d48759680d81ebb2b414"}},o={TOKEN:0,NFT:1,COLLECTION:2}},18832:function(e,t,n){"use strict";n.d(t,{PA:function(){return a},z1:function(){return r}});const r="0xc52d6008",a={LSP7Tokens_SenderNotification:"0x429ac7a06903dbc9c13dfcb3c9d11df8194581fa047c96d7a4171fc7402958ea",LSP7Tokens_RecipientNotification:"0x20804611b3e2ea21c480dc465142210acf4a2485947541770ec1fb87dee4a55c",LSP7Tokens_OperatorNotification:"0x386072cc5a58e61263b434c722725f21031cd06e7c552cfaa06db5de8a320dbc",LSP7Tokens_VotesDelegatorNotification:"0x6117a486162c4ba8e38d646ef52b1e0e1be6bef05a980c041e232eba8c95e16f",LSP7Tokens_VotesDelegateeNotification:"0x72cad372b29cde295ff0839b7b194597766b88f5fad4f7d6aef013e0c55dc492"}},62964:function(e,t,n){"use strict";n.d(t,{s1:function(){return r},uU:function(){return a},z1:function(){return o}});const r="0x3a271706",a={LSP8TokenIdFormat:"0xf675e9361af1c1664c1868cfa3eb97672d6b1a513aa5b81dec34c9ee330e818d",LSP8TokenMetadataBaseURI:"0x1a7628600c3bac7101f53697f48df381ddc36b9015e7d7c9c5633d1252aa2843",LSP8ReferenceContract:"0x708e7b881795f2e6b6c2752108c177ec89248458de3bf69d0d43480b3e5034e6"},o={LSP8Tokens_SenderNotification:"0xb23eae7e6d1564b295b4c3e3be402d9a2f0776c57bdf365903496f6fa481ab00",LSP8Tokens_RecipientNotification:"0x0b084a55ebf70fd3c06fd755269dac2212c4d3f0f4d09079780bfa50c1b2984d",LSP8Tokens_OperatorNotification:"0x8a1c15a8799f71b547e08e2bcb2e85257e81b0a07eee2ce6712549eef1f00970",LSP8Tokens_VotesDelegateeNotification:"0x19419598f788eae88574bbb83ec563ad0cb43cd7ddbbc88857b2efa2d8faa8eb",LSP8Tokens_VotesDelegatorNotification:"0x2f6d3f668c2e57dbae4c255f2d9e0b69d47a8848d69a2251cce137529e34743e"}},35163:function(e,t,n){"use strict";n.d(t,{AP:function(){return r},sr:function(){return a}});const r="0x24871b3d",a={LSP0ValueReceived:"0x9c4705229491d365fb5434052e12a386d6771d976bea61070a8c694e8affea3d",LSP0OwnershipTransferStarted:"0xe17117c9d2665d1dbeb479ed8058bbebde3c50ac50e2e65619f60006caac6926",LSP0OwnershipTransferred_SenderNotification:"0xa4e59c931d14f7c8a7a35027f92ee40b5f2886b9fdcdb78f30bc5ecce5a2f814",LSP0OwnershipTransferred_RecipientNotification:"0xceca317f109c43507871523e82dc2a3cc64dfa18f12da0b6db14f6e23f995538"}},89191:function(e,t,n){"use strict";n.d(t,{l:function(){return a},o:function(){return r}});const r="0x6bb56a14",a={LSP1UniversalReceiverDelegatePrefix:"0x0cfc51aec37c55a4d0b10000",LSP1UniversalReceiverDelegate:"0x0cfc51aec37c55a4d0b1a65c6255c4bf2fbdf6277f3cc0730c45b828b6db8b47"}},39025:function(e,t,n){"use strict";n.d(t,{n:function(){return r}});const r={LSP10VaultsMap:"0x192448c3c0f88c7f238c0000","LSP10Vaults[]":{length:"0x55482936e01da86729a45d2b87a6b1d3bc582bea0ec00e38bdb340e3af6f9f06",index:"0x55482936e01da86729a45d2b87a6b1d3"}}},56893:function(e,t,n){"use strict";n.d(t,{_:function(){return r}});const r="0x23a45ef0"},39453:function(e,t,n){"use strict";n.d(t,{z:function(){return r}});const r={LSP12IssuedAssetsMap:"0x74ac2555c10b9349e78f0000","LSP12IssuedAssets[]":{length:"0x7c8c3416d6cda87cd42c71ea1843df28ac4850354f988d55ee2eaa47b6dc05cd",index:"0x7c8c3416d6cda87cd42c71ea1843df28"}}},40940:function(e,t,n){"use strict";n.d(t,{O:function(){return r},e:function(){return a}});const r="0x94be5999",a={LSP14OwnershipTransferStarted:"0xee9a7c0924f740a2ca33d59b7f0c2929821ea9837ce043ce91c1823e9c4e52c0",LSP14OwnershipTransferred_SenderNotification:"0xa124442e1cc7b52d8e2ede2787d43527dc1f3ae0de87f50dd03e27a71834f74c",LSP14OwnershipTransferred_RecipientNotification:"0xe32c7debcb817925ba4883fdbfc52797187f28f73f860641dab1a68d9b32902c"}},83210:function(e,t,n){"use strict";n.d(t,{g:function(){return r}});const r="0xa245bbda"},13196:function(e,t,n){"use strict";n.d(t,{jI:function(){return r},nz:function(){return a}});const r="0x1a0eb6a5",a="0x0d6ecac7"},94446:function(e,t,n){"use strict";n.d(t,{C:function(){return r}});const r="0x5ac79908"},49135:function(e,t,n){"use strict";n.d(t,{M:function(){return r}});const r="0x2b299cea"},14494:function(e,t,n){"use strict";n.d(t,{k:function(){return r}});const r={LSP5ReceivedAssetsMap:"0x812c4334633eb816c80d0000","LSP5ReceivedAssets[]":{length:"0x6460ee3c0aac563ccbf76d6e1d07bada78e3a9514e6382b736ed3f478ab7b90b",index:"0x6460ee3c0aac563ccbf76d6e1d07bada"}}},61307:function(e,t,n){"use strict";n.d(t,{Xd:function(){return r},hD:function(){return a}});const r="0x23f34c62",a={"AddressPermissions[]":{length:"0xdf30dba06db6a30e65354d9a64c609861f089545ca58c6b4dbe31a5f338cb0e3",index:"0xdf30dba06db6a30e65354d9a64c60986"},AddressPermissionsPrefix:"0x4b80742de2bf","AddressPermissions:Permissions":"0x4b80742de2bf82acb3630000","AddressPermissions:AllowedERC725YDataKeys":"0x4b80742de2bf866c29110000","AddressPermissions:AllowedCalls":"0x4b80742de2bf393a64c70000"}},54529:function(e,t,n){"use strict";n.d(t,{hg:function(){return a},z1:function(){return r}});const r="0xc52d6008",a={"v0.14.0":"0xb3c4928f","v0.12.0":"0xdaa746b7"}},20744:function(e,t,n){"use strict";n.d(t,{s1:function(){return r},zD:function(){return a}});const r="0x3a271706",a={"v0.14.0":"0xecad9f75","v0.12.0":"0x30dc5278"}},1493:function(e,t,n){"use strict";n.d(t,{F1:function(){return o},n5:function(){return c},pf:function(){return r},um:function(){return a}});const r="0x28af17e6",a={key:"0xeafec4d89fa9619884b600007c0334a14085fefa8b51ae5a40895018882bdb90",value:"0x7c0334a1"},o={SupportedStandards_LSP9:a.key},c={LSP9ValueReceived:"0x468cd1581d7bc001c3b685513d2b929b55437be34700410383d58f3aa1ea0abc",LSP9OwnershipTransferStarted:"0xaefd43f45fed1bcd8992f23c803b6f4ec45cf6b62b0d404d565f290a471e763f",LSP9OwnershipTransferred_SenderNotification:"0x0c622e58e6b7089ae35f1af1c86d997be92fcdd8c9509652022d41aa65169471",LSP9OwnershipTransferred_RecipientNotification:"0x79855c97dbc259ce395421d933d7bc0699b0f1561f988f09a9e8633fd542fe5c"}},20943:function(e,t,n){"use strict";function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}n.d(t,{Z:function(){return r}})},47568:function(e,t,n){"use strict";function r(e,t,n,r,a,o,c){try{var i=e[o](c),s=i.value}catch(d){return void n(d)}i.done?t(s):Promise.resolve(s).then(r,a)}function a(e){return function(){var t=this,n=arguments;return new Promise((function(a,o){var c=e.apply(t,n);function i(e){r(c,a,o,i,s,"next",e)}function s(e){r(c,a,o,i,s,"throw",e)}i(void 0)}))}}n.d(t,{Z:function(){return a}})},13375:function(e,t,n){"use strict";function r(e){if("undefined"!==typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}n.d(t,{Z:function(){return r}})},29815:function(e,t,n){"use strict";n.d(t,{Z:function(){return c}});var r=n(20943);var a=n(13375);var o=n(91566);function c(e){return function(e){if(Array.isArray(e))return(0,r.Z)(e)}(e)||(0,a.Z)(e)||(0,o.Z)(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},91566:function(e,t,n){"use strict";n.d(t,{Z:function(){return a}});var r=n(20943);function a(e,t){if(e){if("string"===typeof e)return(0,r.Z)(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(n):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?(0,r.Z)(e,t):void 0}}},77802:function(e){"use strict";e.exports=JSON.parse('[{"name":"SupportedStandards:LSP3Profile","key":"0xeafec4d89fa9619884b600005ef83ad9559033e6e941db7d7c495acdce616347","keyType":"Mapping","valueType":"bytes4","valueContent":"0x5ef83ad9"},{"name":"LSP3Profile","key":"0x5ef83ad9559033e6e941db7d7c495acdce616347d28e90c7ce47cbfcfcad3bc5","keyType":"Singleton","valueType":"bytes","valueContent":"VerifiableURI"},{"name":"LSP12IssuedAssets[]","key":"0x7c8c3416d6cda87cd42c71ea1843df28ac4850354f988d55ee2eaa47b6dc05cd","keyType":"Array","valueType":"address","valueContent":"Address"},{"name":"LSP12IssuedAssetsMap:<address>","key":"0x74ac2555c10b9349e78f0000<address>","keyType":"Mapping","valueType":"(bytes4,uint128)","valueContent":"(Bytes4,Number)"},{"name":"LSP5ReceivedAssets[]","key":"0x6460ee3c0aac563ccbf76d6e1d07bada78e3a9514e6382b736ed3f478ab7b90b","keyType":"Array","valueType":"address","valueContent":"Address"},{"name":"LSP5ReceivedAssetsMap:<address>","key":"0x812c4334633eb816c80d0000<address>","keyType":"Mapping","valueType":"(bytes4,uint128)","valueContent":"(Bytes4,Number)"},{"name":"LSP1UniversalReceiverDelegate","key":"0x0cfc51aec37c55a4d0b1a65c6255c4bf2fbdf6277f3cc0730c45b828b6db8b47","keyType":"Singleton","valueType":"address","valueContent":"Address"},{"name":"LSP1UniversalReceiverDelegate:<bytes32>","key":"0x0cfc51aec37c55a4d0b10000<bytes32>","keyType":"Mapping","valueType":"address","valueContent":"Address"},{"name":"LSP17Extension:<bytes4>","key":"0xcee78b4094da860110960000<bytes4>","keyType":"Mapping","valueType":"address","valueContent":"Address"}]')}}]);