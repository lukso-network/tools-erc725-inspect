"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[0],{29294:(e,t,a)=>{a.d(t,{RC:()=>T,Un:()=>I,Xl:()=>k,nX:()=>s.nX});var n=a(90802),s=a(62132),o=a(73966),r=a(71738),i=a(73488),d=a(49859),l=a(12683),y=a(1313),c=a(34714),u=a(92841),p=a(49480),h=a(17819),f=a(66109),b=a(32614),m=a(71760),v=a(62410),g=a(99520),w=a(6526);let T={LSP0ERC725Account:{"0xead3fbdf":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0x01bfba61":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0xffa1ad74":{sig:"VERSION()",inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",userdoc:{notice:"Contract version."}},"0x79ba5097":{sig:"acceptOwnership()",inputs:[],name:"acceptOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Only the {pendingOwner} can call this function. - When notifying the previous owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_SenderNotification]. - When notifying the new owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_RecipientNotification].",details:"Transfer ownership of the contract from the current {owner()} to the {pendingOwner()}. Once this function is called: - The current {owner()} will lose access to the functions restricted to the {owner()} only. - The {pendingOwner()} will gain access to the functions restricted to the {owner()} only."},userdoc:{notice:"`msg.sender` is accepting ownership of contract: `address(this)`."}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x44c028fe":{sig:"execute(uint256,address,uint256,bytes)",inputs:[{internalType:"uint256",name:"operationType",type:"uint256"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"execute",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0), `STATICCALL` (3) and `DELEGATECALL` (4). - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2). - {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens.","custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3) or `DELEGATECALL` (4), `value` transfer is disallowed and must be 0.",details:"Generic executor function to: - send native tokens to any address. - interact with any contract by passing an abi-encoded function call in the `data` parameter. - deploy a contract by providing its creation bytecode in the `data` parameter.",params:{data:"The call data, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationType:"The operation type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",target:"The address of the EOA or smart contract.  (unused if a contract is created via operation type 1 or 2)",value:"The amount of native tokens to transfer (in Wei)"}},userdoc:{notice:"Calling address `target` using `operationType`, transferring `value` wei and data: `data`."}},"0x31858452":{sig:"executeBatch(uint256[],address[],uint256[],bytes[])",inputs:[{internalType:"uint256[]",name:"operationsType",type:"uint256[]"},{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"datas",type:"bytes[]"}],name:"executeBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0), `STATICCALL` (3) and `DELEGATECALL` (4). (each iteration) - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2) (each iteration) - {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens.","custom:requirements":"- The length of the parameters provided must be equal. - Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3) or `DELEGATECALL` (4), `value` transfer is disallowed and must be 0.","custom:warning":"- The `msg.value` should not be trusted for any method called within the batch with `operationType`: `DELEGATECALL` (4).",details:"Batch executor function that behaves the same as {execute} but allowing multiple operations in the same transaction.",params:{datas:"The list of calldata, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationsType:"The list of operations type used: `CALL = 0`; `CREATE = 1`; `CREATE2 = 2`; `STATICCALL = 3`; `DELEGATECALL = 4`",targets:"The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",values:"The list of native token amounts to transfer (in Wei)."}},userdoc:{notice:"Calling multiple addresses `targets` using `operationsType`, transferring `values` wei and data: `datas`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1626ba7e":{sig:"isValidSignature(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataHash",type:"bytes32"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"isValidSignature",outputs:[{internalType:"bytes4",name:"returnedStatus",type:"bytes4"}],stateMutability:"view",type:"function",devdoc:{"custom:warning":"This function does not enforce by default the inclusion of the address of this contract in the signature digest. It is recommended that protocols or applications using this contract include the targeted address (= this contract) in the data to sign. To ensure that a signature is valid for a specific LSP0ERC725Account and prevent signatures from the same EOA to be replayed across different LSP0ERC725Accounts.",details:"Handles two cases: 1. If the owner is an EOA, recovers an address from the hash and the signature provided:      - Returns the `_ERC1271_SUCCESSVALUE` if the address recovered is the same as the owner, indicating that it was a valid signature.      - If the address is different, it returns the `_ERC1271_FAILVALUE` indicating that the signature is not valid. 2. If the owner is a smart contract, it forwards the call of {isValidSignature()} to the owner contract:      - If the contract fails or returns the `_ERC1271_FAILVALUE`, the {isValidSignature()} on the account returns the `_ERC1271_FAILVALUE`, indicating that the signature is not valid.      - If the {isValidSignature()} on the owner returned the `_ERC1271_SUCCESSVALUE`, the {isValidSignature()} on the account returns the `_ERC1271_SUCCESSVALUE`, indicating that it's a valid signature.",params:{dataHash:"The hash of the data to be validated.",signature:"A signature that can validate the previous parameter (Hash)."},returns:{returnedStatus:"A `bytes4` value that indicates if the signature is valid or not."}},userdoc:{notice:"Achieves the goal of [EIP-1271] by validating signatures of smart contracts according to their own logic."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0xe30c3978":{sig:"pendingOwner()",inputs:[],name:"pendingOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{"custom:info":"If no ownership transfer is in progress, the pendingOwner will be `address(0).`.",details:"The address that ownership of the contract is transferred to. This address may use {acceptOwnership()} to gain ownership of the contract."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"Leaves the contract without an owner. Once ownership of the contract has been renounced, any functions that are restricted to be called by the owner or an address allowed by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Renounce ownership of the contract in a 2-step process. 1. The first call will initiate the process of renouncing ownership. 2. The second call is used as a confirmation and will leave the contract without an owner."},userdoc:{notice:"`msg.sender` is renouncing ownership of contract `address(this)`."}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens. - {DataChanged} event.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens. - {DataChanged} event. (on each iteration of setting data)","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Achieves the goal of [ERC-165] to detect supported interfaces and [LSP-17-ContractExtension] by checking if the interfaceId being queried is supported on another linked extension. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to [LSP-17-ContractExtension], and checks if the extension implements the interface defined by `interfaceId`.",params:{interfaceId:"The interface ID to check if the contract supports it."},returns:{_0:"`true` if this contract implements the interface defined by `interfaceId`, `false` otherwise."}},userdoc:{notice:"Checking if this contract supports the interface defined by the `bytes4` interface ID `interfaceId`."}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"pendingNewOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - When notifying the new owner via LSP1, the `typeId` used must be the `keccak256(...)` hash of [LSP0OwnershipTransferStarted]. - Pending owner cannot accept ownership in the same tx via the LSP1 hook.",details:"Initiate the process of transferring ownership of the contract by setting the new owner as the pending owner. If the new owner is a contract that supports + implements LSP1, this will also attempt to notify the new owner that ownership has been transferred to them by calling the {universalReceiver()} function on the `newOwner` contract.",params:{newOwner:"The address of the new owner."}},userdoc:{notice:"Transfer ownership initiated by `newOwner`."}},"0x6bb56a14":{sig:"universalReceiver(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"typeId",type:"bytes32"},{internalType:"bytes",name:"receivedData",type:"bytes"}],name:"universalReceiver",outputs:[{internalType:"bytes",name:"returnedValues",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} with typeId {`LSP0ValueReceived`} when receiving native tokens. - {UniversalReceiver} event with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract that was called.",details:"Achieves the goal of [LSP-1-UniversalReceiver] by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts ([LSP1UniversalReceiverDelegate]) that react on the whole transaction and on the specific typeId, respectively. The function performs the following steps: 1. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY].      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. 2. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX] + `bytes32(typeId)`.   (Check [LSP-2-ERC725YJSONSchema] for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. This function delegates internally the handling of native tokens to the {universalReceiver} function itself passing `_TYPEID_LSP0_VALUE_RECEIVED` as typeId and the calldata as received data.",params:{receivedData:"The data received.",typeId:"The type of call received."},returns:{returnedValues:"The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call."}},userdoc:{notice:"Notifying the contract by calling its `universalReceiver` function with the following information: typeId: `typeId`; data: `data`."}}},LSP0ERC725AccountInit:{"0xead3fbdf":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0x01bfba61":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0xffa1ad74":{sig:"VERSION()",inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",userdoc:{notice:"Contract version."}},"0x79ba5097":{sig:"acceptOwnership()",inputs:[],name:"acceptOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Only the {pendingOwner} can call this function. - When notifying the previous owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_SenderNotification]. - When notifying the new owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_RecipientNotification].",details:"Transfer ownership of the contract from the current {owner()} to the {pendingOwner()}. Once this function is called: - The current {owner()} will lose access to the functions restricted to the {owner()} only. - The {pendingOwner()} will gain access to the functions restricted to the {owner()} only."},userdoc:{notice:"`msg.sender` is accepting ownership of contract: `address(this)`."}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x44c028fe":{sig:"execute(uint256,address,uint256,bytes)",inputs:[{internalType:"uint256",name:"operationType",type:"uint256"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"execute",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0), `STATICCALL` (3) and `DELEGATECALL` (4). - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2). - {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens.","custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3) or `DELEGATECALL` (4), `value` transfer is disallowed and must be 0.",details:"Generic executor function to: - send native tokens to any address. - interact with any contract by passing an abi-encoded function call in the `data` parameter. - deploy a contract by providing its creation bytecode in the `data` parameter.",params:{data:"The call data, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationType:"The operation type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",target:"The address of the EOA or smart contract.  (unused if a contract is created via operation type 1 or 2)",value:"The amount of native tokens to transfer (in Wei)"}},userdoc:{notice:"Calling address `target` using `operationType`, transferring `value` wei and data: `data`."}},"0x31858452":{sig:"executeBatch(uint256[],address[],uint256[],bytes[])",inputs:[{internalType:"uint256[]",name:"operationsType",type:"uint256[]"},{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"datas",type:"bytes[]"}],name:"executeBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0), `STATICCALL` (3) and `DELEGATECALL` (4). (each iteration) - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2) (each iteration) - {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens.","custom:requirements":"- The length of the parameters provided must be equal. - Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3) or `DELEGATECALL` (4), `value` transfer is disallowed and must be 0.","custom:warning":"- The `msg.value` should not be trusted for any method called within the batch with `operationType`: `DELEGATECALL` (4).",details:"Batch executor function that behaves the same as {execute} but allowing multiple operations in the same transaction.",params:{datas:"The list of calldata, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationsType:"The list of operations type used: `CALL = 0`; `CREATE = 1`; `CREATE2 = 2`; `STATICCALL = 3`; `DELEGATECALL = 4`",targets:"The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",values:"The list of native token amounts to transfer (in Wei)."}},userdoc:{notice:"Calling multiple addresses `targets` using `operationsType`, transferring `values` wei and data: `datas`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0xc4d66de8":{sig:"initialize(address)",inputs:[{internalType:"address",name:"initialOwner",type:"address"}],name:"initialize",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with typeId `LSP0ValueReceived` when funding the contract on initialization. - {OwnershipTransferred} event when `initialOwner` is set as the contract {owner}.",details:"Set `initialOwner` as the contract owner. The `initialize(address)` also allows funding the contract on deployment.",params:{initialOwner:"The owner of the contract."}},userdoc:{notice:"Initializing a LSP0ERC725Account contract with owner set to address `initialOwner`."}},"0x1626ba7e":{sig:"isValidSignature(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataHash",type:"bytes32"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"isValidSignature",outputs:[{internalType:"bytes4",name:"returnedStatus",type:"bytes4"}],stateMutability:"view",type:"function",devdoc:{"custom:warning":"This function does not enforce by default the inclusion of the address of this contract in the signature digest. It is recommended that protocols or applications using this contract include the targeted address (= this contract) in the data to sign. To ensure that a signature is valid for a specific LSP0ERC725Account and prevent signatures from the same EOA to be replayed across different LSP0ERC725Accounts.",details:"Handles two cases: 1. If the owner is an EOA, recovers an address from the hash and the signature provided:      - Returns the `_ERC1271_SUCCESSVALUE` if the address recovered is the same as the owner, indicating that it was a valid signature.      - If the address is different, it returns the `_ERC1271_FAILVALUE` indicating that the signature is not valid. 2. If the owner is a smart contract, it forwards the call of {isValidSignature()} to the owner contract:      - If the contract fails or returns the `_ERC1271_FAILVALUE`, the {isValidSignature()} on the account returns the `_ERC1271_FAILVALUE`, indicating that the signature is not valid.      - If the {isValidSignature()} on the owner returned the `_ERC1271_SUCCESSVALUE`, the {isValidSignature()} on the account returns the `_ERC1271_SUCCESSVALUE`, indicating that it's a valid signature.",params:{dataHash:"The hash of the data to be validated.",signature:"A signature that can validate the previous parameter (Hash)."},returns:{returnedStatus:"A `bytes4` value that indicates if the signature is valid or not."}},userdoc:{notice:"Achieves the goal of [EIP-1271] by validating signatures of smart contracts according to their own logic."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0xe30c3978":{sig:"pendingOwner()",inputs:[],name:"pendingOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{"custom:info":"If no ownership transfer is in progress, the pendingOwner will be `address(0).`.",details:"The address that ownership of the contract is transferred to. This address may use {acceptOwnership()} to gain ownership of the contract."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"Leaves the contract without an owner. Once ownership of the contract has been renounced, any functions that are restricted to be called by the owner or an address allowed by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Renounce ownership of the contract in a 2-step process. 1. The first call will initiate the process of renouncing ownership. 2. The second call is used as a confirmation and will leave the contract without an owner."},userdoc:{notice:"`msg.sender` is renouncing ownership of contract `address(this)`."}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens. - {DataChanged} event.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens. - {DataChanged} event. (on each iteration of setting data)","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Achieves the goal of [ERC-165] to detect supported interfaces and [LSP-17-ContractExtension] by checking if the interfaceId being queried is supported on another linked extension. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to [LSP-17-ContractExtension], and checks if the extension implements the interface defined by `interfaceId`.",params:{interfaceId:"The interface ID to check if the contract supports it."},returns:{_0:"`true` if this contract implements the interface defined by `interfaceId`, `false` otherwise."}},userdoc:{notice:"Checking if this contract supports the interface defined by the `bytes4` interface ID `interfaceId`."}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"pendingNewOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - When notifying the new owner via LSP1, the `typeId` used must be the `keccak256(...)` hash of [LSP0OwnershipTransferStarted]. - Pending owner cannot accept ownership in the same tx via the LSP1 hook.",details:"Initiate the process of transferring ownership of the contract by setting the new owner as the pending owner. If the new owner is a contract that supports + implements LSP1, this will also attempt to notify the new owner that ownership has been transferred to them by calling the {universalReceiver()} function on the `newOwner` contract.",params:{newOwner:"The address of the new owner."}},userdoc:{notice:"Transfer ownership initiated by `newOwner`."}},"0x6bb56a14":{sig:"universalReceiver(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"typeId",type:"bytes32"},{internalType:"bytes",name:"receivedData",type:"bytes"}],name:"universalReceiver",outputs:[{internalType:"bytes",name:"returnedValues",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} with typeId {`LSP0ValueReceived`} when receiving native tokens. - {UniversalReceiver} event with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract that was called.",details:"Achieves the goal of [LSP-1-UniversalReceiver] by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts ([LSP1UniversalReceiverDelegate]) that react on the whole transaction and on the specific typeId, respectively. The function performs the following steps: 1. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY].      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. 2. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX] + `bytes32(typeId)`.   (Check [LSP-2-ERC725YJSONSchema] for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. This function delegates internally the handling of native tokens to the {universalReceiver} function itself passing `_TYPEID_LSP0_VALUE_RECEIVED` as typeId and the calldata as received data.",params:{receivedData:"The data received.",typeId:"The type of call received."},returns:{returnedValues:"The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call."}},userdoc:{notice:"Notifying the contract by calling its `universalReceiver` function with the following information: typeId: `typeId`; data: `data`."}}},LSP11SocialRecovery:{"0xb79336ee":{sig:"COMMITMEMT_DELAY()",inputs:[],name:"COMMITMEMT_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"The delay between the commitment and the recovery process."}},"0x8bc0ab75":{sig:"DEFAULT_RECOVERY_DELAY()",inputs:[],name:"DEFAULT_RECOVERY_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"The default recovery delay set to 40 minutes."}},"0xc6845210":{sig:"addGuardian(address,address)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"newGuardian",type:"address"}],name:"addGuardian",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"This function allows the account holder to add a new guardian to their account. If the provided address is already a guardian for the account, the function will revert. Emits a `GuardianAdded` event upon successful addition of the guardian.",params:{account:"The address of the account to which the guardian will be added.",newGuardian:"The address of the new guardian to be added."}},userdoc:{notice:"Adds a new guardian to the calling account."}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{details:"This function allows for multiple calls to be made in a single transaction, improving efficiency. If a call fails, the function will attempt to bubble up the revert reason or revert with a default message.",params:{data:"An array of calldata bytes to be executed."},returns:{results:"An array of bytes containing the results of each executed call."}},userdoc:{notice:"Executes multiple calls in a single transaction."}},"0x1ce59666":{sig:"cancelRecoveryProcess(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"cancelRecoveryProcess",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"This function allows the account holder to cancel the ongoing recovery process by incrementing the recovery counter. Emits a `RecoveryCancelled` event upon successful cancellation of the recovery process.",params:{account:"The address of the account to which the recovery process will be canceled."}},userdoc:{notice:"Cancels the ongoing recovery process for the account by increasing the recovery counter."}},"0xa9e3b276":{sig:"commitToRecover(address,address,bytes32)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"votedAddress",type:"address"},{internalType:"bytes32",name:"commitment",type:"bytes32"}],name:"commitToRecover",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"This function allows an address to commit a secret hash for the recovery process. If the guardian has not voted for the provided address, the function will revert. The commitment in this implementation is `keccak256(abi.encode(votedAddress, secretHash)`.",params:{account:"The account for which the secret hash is being committed.",commitment:"The commitment associated with the secret hash."}},userdoc:{notice:"Commits a secret hash for an address to be recovered."}},"0x4c8a4e74":{sig:"executeRelayCall(bytes,uint256,uint256,bytes)",inputs:[{internalType:"bytes",name:"signature",type:"bytes"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"validityTimestamps",type:"uint256"},{internalType:"bytes",name:"payload",type:"bytes"}],name:"executeRelayCall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{details:"Allows any address (executor) to execute a payload (= abi-encoded function call), given they have a valid signature from a signer address and a valid `nonce` for this signer. The signature MUST be generated according to the signature format defined by the LSP25 standard.",params:{nonce:"The nonce of the address that signed the calldata (in a specific `_channel`), obtained via {getNonce}. Used to prevent replay attack.",payload:"The abi-encoded function call to execute.",signature:"A 65 bytes long signature for a meta transaction according to LSP25.",validityTimestamps:'Two `uint128` timestamps concatenated together that describes when the relay transaction is valid "from" (left `uint128`) and "until" as a deadline (right `uint128`).'},returns:{_0:"The data being returned by the function executed."}},userdoc:{notice:"Executing the following payload given the nonce `nonce` and signature `signature`. Payload: `payload`"}},"0xa20856a5":{sig:"executeRelayCallBatch(bytes[],uint256[],uint256[],uint256[],bytes[])",inputs:[{internalType:"bytes[]",name:"signatures",type:"bytes[]"},{internalType:"uint256[]",name:"nonces",type:"uint256[]"},{internalType:"uint256[]",name:"validityTimestamps",type:"uint256[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"payloads",type:"bytes[]"}],name:"executeRelayCallBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{details:"Same as {executeRelayCall} but execute a batch of signed calldata payloads (abi-encoded function calls) in a single transaction.",params:{nonces:"An array of nonces of the addresses that signed the calldata payloads (in specific channels). Obtained via {getNonce}. Used to prevent replay attack.",payloads:"An array of abi-encoded function calls to be executed successively.",signatures:"An array of 65 bytes long signatures for meta transactions according to LSP25.",validityTimestamps:'An array of two `uint128` concatenated timestamps that describe when the relay transaction is valid "from" (left `uint128`) and "until" (right `uint128`).',values:"An array of amount of native tokens to be transferred for each calldata `payload`."},returns:{_0:"An array of abi-decoded data returned by the functions executed."}},userdoc:{notice:"Executing a batch of relay calls (= meta-transactions)."}},"0x6289a163":{sig:"getCommitmentInfoOf(address,uint256,address)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"recoveryCounter",type:"uint256"},{internalType:"address",name:"committedBy",type:"address"}],name:"getCommitmentInfoOf",outputs:[{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{params:{account:"The account for which the commitment is queried.",committedBy:"The address who made the commitment.",recoveryCounter:"The recovery counter for which the commitment is queried."},returns:{_0:"The bytes32 commitment and its timestamp associated with the specified address for recovery for the given account and recovery counter."}},userdoc:{notice:"Get the commitment associated with an address for recovery for a specific account and recovery counter."}},"0x88095527":{sig:"getFirstRecoveryTimestampOf(address,uint256)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"recoveryCounter",type:"uint256"}],name:"getFirstRecoveryTimestampOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{params:{account:"The account for which the vote is queried.",recoveryCounter:"The recovery counter for which the vote is queried."},returns:{_0:"The timestamp of the first recovery timestamp of the vote for a specific account and recovery counter."}},userdoc:{notice:"Get the timestamp of the first recovery timestamp of the vote for a specific account and recovery counter."}},"0x8ca4aaaf":{sig:"getGuardiansOf(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"getGuardiansOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{params:{account:"The account for which guardians are queried."},returns:{_0:"An array of addresses representing guardians for the given account."}},userdoc:{notice:"Get the array of addresses representing guardians associated with an account."}},"0xdbd119bd":{sig:"getGuardiansThresholdOf(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"getGuardiansThresholdOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{params:{account:"The account for which the guardian threshold is queried."},returns:{_0:"The guardian threshold set for the given account."}},userdoc:{notice:"Get the guardian threshold for a specific account."}},"0xb44581d9":{sig:"getNonce(address,uint128)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"uint128",name:"channelId",type:"uint128"}],name:"getNonce",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the nonce for a specific `from` address that can be used for signing relay transactions via {executeRelayCall}.",params:{channelId:"The channel id that the signer wants to use for executing the transaction.",from:"The address of the signer of the transaction."},returns:{_0:"The current nonce on a specific `channelId`."}},userdoc:{notice:"Reading the latest nonce of address `from` in the channel ID `channelId`."}},"0xcee79d45":{sig:"getRecoveryCounterOf(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"getRecoveryCounterOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{params:{account:"The account for which the recovery counter is queried."},returns:{_0:"The successful recovery counter for the given account."}},userdoc:{notice:"Get the successful recovery counter for a specific account."}},"0x02543bff":{sig:"getRecoveryDelayOf(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"getRecoveryDelayOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{params:{account:"The account for which the recovery delay is queried."},returns:{_0:"The recovery delay associated with the given account."}},userdoc:{notice:"Get the recovery delay associated with a specific account."}},"0x06fe1738":{sig:"getSecretHashOf(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"getSecretHashOf",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",devdoc:{params:{account:"The account for which the secret hash is queried."},returns:{_0:"The secret hash associated with the given account."}},userdoc:{notice:"Get the secret hash associated with a specific account."}},"0x506d1a0f":{sig:"getVotedAddressByGuardian(address,uint256,address)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"recoveryCounter",type:"uint256"},{internalType:"address",name:"guardian",type:"address"}],name:"getVotedAddressByGuardian",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{params:{account:"The account for which the vote is queried.",guardian:"The guardian whose vote is queried.",recoveryCounter:"The recovery counter for which the vote is queried."},returns:{_0:"The address voted for recovery by the specified guardian for the given account and recovery counter."}},userdoc:{notice:"Get the address voted for recovery by a guardian for a specific account and recovery counter."}},"0xa65068b6":{sig:"getVotesOfGuardianVotedAddress(address,uint256,address)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"recoveryCounter",type:"uint256"},{internalType:"address",name:"votedAddress",type:"address"}],name:"getVotesOfGuardianVotedAddress",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{params:{account:"The account for which the votes are queried.",recoveryCounter:"The recovery counter for which the votes are queried.",votedAddress:"The address for which the votes are queried."},returns:{_0:"The number of votes the specified address has received from guardians for the given account and recovery counter."}},userdoc:{notice:"Get the number of votes an address has received from guardians for a specific account and recovery counter."}},"0xd617b890":{sig:"hasReachedThreshold(address,uint256,address)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"recoveryCounter",type:"uint256"},{internalType:"address",name:"votedAddress",type:"address"}],name:"hasReachedThreshold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"This function evaluates if the number of votes from guardians for a specific voted address meets or exceeds the required threshold for account recovery. This is part of the account recovery process where guardians vote for the legitimacy of a recovery address.",params:{account:"The account for which the threshold check is performed.",recoveryCounter:"The recovery counter for which the threshold check is performed.",votedAddress:"The address for which the votes are counted."},returns:{_0:"A boolean indicating whether the votes for the specified address have reached the necessary threshold for the given account and recovery counter."}},userdoc:{notice:"Checks if the votes received by a given address from guardians have reached the threshold necessary for account recovery."}},"0x769e54df":{sig:"isGuardianOf(address,address)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"guardianAddress",type:"address"}],name:"isGuardianOf",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{params:{account:"The account to check for guardian status.",guardianAddress:"The address to verify if it's a guardian for the given account.."},returns:{_0:"A boolean indicating whether the address is a guardian for the given account."}},userdoc:{notice:"Check if an address is a guardian for a specific account."}},"0xf3b3c785":{sig:"recoverAccess(address,address,bytes32,bytes32,bytes)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"votedAddress",type:"address"},{internalType:"bytes32",name:"secretHash",type:"bytes32"},{internalType:"bytes32",name:"newSecretHash",type:"bytes32"},{internalType:"bytes",name:"calldataToExecute",type:"bytes"}],name:"recoverAccess",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{details:"This function initiates the account recovery process and executes the provided calldata. If the new secret hash is zero or the number of votes is less than the guardian threshold, the function will revert. Emits a `RecoveryProcessSuccessful` event upon successful recovery process.",params:{account:"The account for which the recovery is being initiated.",calldataToExecute:"The calldata to be executed during the recovery process.",newSecretHash:"The new secret hash to be set for the account.",secretHash:"The secret hash associated with the recovery process unsalted with the account address."}},userdoc:{notice:"Initiates the account recovery process."}},"0x9b27a90e":{sig:"removeGuardian(address,address)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"existingGuardian",type:"address"}],name:"removeGuardian",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"This function allows the account holder to remove an existing guardian from their account. If the provided address is not a current guardian or the removal would violate the guardian threshold, the function will revert. Emits a `GuardianRemoved` event upon successful removal of the guardian.",params:{account:"The address of the account to which the guardian will be removed.",existingGuardian:"The address of the existing guardian to be removed."}},userdoc:{notice:"Removes an existing guardian from the calling account."}},"0x639cea19":{sig:"setGuardiansThreshold(address,uint256)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"newThreshold",type:"uint256"}],name:"setGuardiansThreshold",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"This function allows the account holder to set the guardian threshold for their account. If the provided threshold exceeds the number of current guardians, the function will revert. Emits a `GuardiansThresholdChanged` event upon successful threshold modification.",params:{account:"The address of the account to which the threshold will be set.",newThreshold:"The new guardian threshold to be set for the calling account."}},userdoc:{notice:"Sets the guardian threshold for the calling account."}},"0xa219b404":{sig:"setRecoveryDelay(address,uint256)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"recoveryDelay",type:"uint256"}],name:"setRecoveryDelay",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"This function allows the account to set a new recovery delay for their account. Emits a `RecoveryDelayChanged` event upon successful secret hash modification.",params:{account:"The address of the account to which the recovery delay will be set.",recoveryDelay:"The new recovery delay in seconds to be set for the calling account."}},userdoc:{notice:"Sets the recovery delay for the calling account."}},"0x78f84ebd":{sig:"setRecoverySecretHash(address,bytes32)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"bytes32",name:"newRecoverSecretHash",type:"bytes32"}],name:"setRecoverySecretHash",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"This function allows the account holder to set a new recovery secret hash for their account. In this implementation, the secret hash MUST be set salted with the account address, using keccak256(abi.encode(account, secretHash)). Emits a `SecretHashChanged` event upon successful secret hash modification.",params:{account:"The address of the account to which the recovery secret hash will be set.",newRecoverSecretHash:"The new recovery secret hash to be set for the calling account."}},userdoc:{notice:"Sets the recovery secret hash for the calling account."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xfa04a7f1":{sig:"voteForRecovery(address,address,address)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"guardian",type:"address"},{internalType:"address",name:"guardianVotedAddress",type:"address"}],name:"voteForRecovery",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"This function allows a guardian to vote for an address to be recovered in a recovery process. If the guardian has already voted for the provided address, the function will revert. Emits a `GuardianVotedFor` event upon successful vote.",params:{account:"The account for which the vote is being cast.",guardianVotedAddress:"The address voted by the guardian for recovery."}},userdoc:{notice:"Allows a guardian to vote for an address for a recovery process"}}},LSP1UniversalReceiverDelegateUP:{"0xffa1ad74":{sig:"VERSION()",inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",userdoc:{notice:"Contract version."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa245bbda":{sig:"universalReceiverDelegate(address,uint256,bytes32,bytes)",inputs:[{internalType:"address",name:"notifier",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes32",name:"typeId",type:"bytes32"},{internalType:"bytes",name:"",type:"bytes"}],name:"universalReceiverDelegate",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"- If some issues occurred with generating the `dataKeys` or `dataValues` the `returnedMessage` will be an error message, otherwise it will be empty. - If an error occurred when trying to use `setDataBatch(dataKeys,dataValues)`, it will return the raw error data back to the caller.","custom:requirements":"- This contract should be allowed to use the {setDataBatch(...)} function in order to update the LSP5 and LSP10 Data Keys. - Cannot accept native tokens","custom:warning":"When the data stored in the ERC725Y storage of the LSP0 contract is corrupted (_e.g: ([LSP-5-ReceivedAssets]'s Array length not 16 bytes long, the token received is already registered in `LSP5ReceivetAssets[]`, the token being sent is not sent as full balance, etc...), the function call will still pass and return (**not revert!**) and not modify any data key on the storage of the [LSP-0-ERC725Account].",details:"1. Writes the data keys of the received [LSP-7-DigitalAsset], [LSP-8-IdentifiableDigitalAsset] and [LSP-9-Vault] contract addresses into the account storage according to the [LSP-5-ReceivedAssets] and [LSP-10-ReceivedVaults] Standard. 2. The data keys representing an asset/vault are cleared when the asset/vault is no longer owned by the account.",params:{typeId:"Unique identifier for a specific notification."},returns:{_0:"The result of the reaction for `typeId`."}},userdoc:{notice:"Reacted on received notification with `typeId`."}}},LSP1UniversalReceiverDelegateVault:{"0xffa1ad74":{sig:"VERSION()",inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",userdoc:{notice:"Contract version."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa245bbda":{sig:"universalReceiverDelegate(address,uint256,bytes32,bytes)",inputs:[{internalType:"address",name:"notifier",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes32",name:"typeId",type:"bytes32"},{internalType:"bytes",name:"",type:"bytes"}],name:"universalReceiverDelegate",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"- If some issues occurred with generating the `dataKeys` or `dataValues` the `returnedMessage` will be an error message, otherwise it will be empty. - If an error occurred when trying to use `setDataBatch(dataKeys,dataValues)`, it will return the raw error data back to the caller.","custom:requirements":"Cannot accept native tokens.",details:"Handles two cases: Writes the received [LSP-7-DigitalAsset] or [LSP-8-IdentifiableDigitalAsset] assets into the vault storage according to the [LSP-5-ReceivedAssets] standard.",params:{typeId:"Unique identifier for a specific notification."},returns:{_0:"The result of the reaction for `typeId`."}},userdoc:{notice:"Reacted on received notification with `typeId`."}}},LSP23LinkedContractsFactory:{"0xdd5940f3":{sig:"computeAddresses((bytes32,uint256,bytes),(uint256,bytes,bool,bytes),address,bytes)",inputs:[{components:[{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256",name:"fundingAmount",type:"uint256"},{internalType:"bytes",name:"creationBytecode",type:"bytes"}],internalType:"struct ILSP23LinkedContractsFactory.PrimaryContractDeployment",name:"primaryContractDeployment",type:"tuple"},{components:[{internalType:"uint256",name:"fundingAmount",type:"uint256"},{internalType:"bytes",name:"creationBytecode",type:"bytes"},{internalType:"bool",name:"addPrimaryContractAddress",type:"bool"},{internalType:"bytes",name:"extraConstructorParams",type:"bytes"}],internalType:"struct ILSP23LinkedContractsFactory.SecondaryContractDeployment",name:"secondaryContractDeployment",type:"tuple"},{internalType:"address",name:"postDeploymentModule",type:"address"},{internalType:"bytes",name:"postDeploymentModuleCalldata",type:"bytes"}],name:"computeAddresses",outputs:[{internalType:"address",name:"primaryContractAddress",type:"address"},{internalType:"address",name:"secondaryContractAddress",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Computes the addresses of a primary contract and a secondary linked contract",params:{postDeploymentModule:"The optional module to be executed after deployment",postDeploymentModuleCalldata:"The data to be passed to the post deployment module",primaryContractDeployment:"Contains the needed parameter to deploy the primary contract. (`salt`, `fundingAmount`, `creationBytecode`)",secondaryContractDeployment:"Contains the needed parameter to deploy the secondary contract. (`fundingAmount`, `creationBytecode`, `addPrimaryContractAddress`, `extraConstructorParams`)"},returns:{primaryContractAddress:"The address of the deployed primary contract.",secondaryContractAddress:"The address of the deployed secondary contract."}}},"0x72b19d36":{sig:"computeERC1167Addresses((bytes32,uint256,address,bytes),(uint256,address,bytes,bool,bytes),address,bytes)",inputs:[{components:[{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256",name:"fundingAmount",type:"uint256"},{internalType:"address",name:"implementationContract",type:"address"},{internalType:"bytes",name:"initializationCalldata",type:"bytes"}],internalType:"struct ILSP23LinkedContractsFactory.PrimaryContractDeploymentInit",name:"primaryContractDeploymentInit",type:"tuple"},{components:[{internalType:"uint256",name:"fundingAmount",type:"uint256"},{internalType:"address",name:"implementationContract",type:"address"},{internalType:"bytes",name:"initializationCalldata",type:"bytes"},{internalType:"bool",name:"addPrimaryContractAddress",type:"bool"},{internalType:"bytes",name:"extraInitializationParams",type:"bytes"}],internalType:"struct ILSP23LinkedContractsFactory.SecondaryContractDeploymentInit",name:"secondaryContractDeploymentInit",type:"tuple"},{internalType:"address",name:"postDeploymentModule",type:"address"},{internalType:"bytes",name:"postDeploymentModuleCalldata",type:"bytes"}],name:"computeERC1167Addresses",outputs:[{internalType:"address",name:"primaryContractAddress",type:"address"},{internalType:"address",name:"secondaryContractAddress",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Computes the addresses of a primary and a secondary linked contracts ERC1167 proxies to be created",params:{postDeploymentModule:"The optional module to be executed after deployment.",postDeploymentModuleCalldata:"The data to be passed to the post deployment module.",primaryContractDeploymentInit:"Contains the needed parameters to deploy a primary proxy contract. (`salt`, `fundingAmount`, `implementationContract`, `initializationCalldata`)",secondaryContractDeploymentInit:"Contains the needed parameters to deploy the secondary proxy contract. (`fundingAmount`, `implementationContract`, `initializationCalldata`, `addPrimaryContractAddress`, `extraInitializationParams`)"},returns:{primaryContractAddress:"The address of the deployed primary contract proxy",secondaryContractAddress:"The address of the deployed secondary contract proxy"}}},"0x754b86b5":{sig:"deployContracts((bytes32,uint256,bytes),(uint256,bytes,bool,bytes),address,bytes)",inputs:[{components:[{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256",name:"fundingAmount",type:"uint256"},{internalType:"bytes",name:"creationBytecode",type:"bytes"}],internalType:"struct ILSP23LinkedContractsFactory.PrimaryContractDeployment",name:"primaryContractDeployment",type:"tuple"},{components:[{internalType:"uint256",name:"fundingAmount",type:"uint256"},{internalType:"bytes",name:"creationBytecode",type:"bytes"},{internalType:"bool",name:"addPrimaryContractAddress",type:"bool"},{internalType:"bytes",name:"extraConstructorParams",type:"bytes"}],internalType:"struct ILSP23LinkedContractsFactory.SecondaryContractDeployment",name:"secondaryContractDeployment",type:"tuple"},{internalType:"address",name:"postDeploymentModule",type:"address"},{internalType:"bytes",name:"postDeploymentModuleCalldata",type:"bytes"}],name:"deployContracts",outputs:[{internalType:"address",name:"primaryContractAddress",type:"address"},{internalType:"address",name:"secondaryContractAddress",type:"address"}],stateMutability:"payable",type:"function",devdoc:{details:"Deploys a primary and a secondary linked contract.",params:{postDeploymentModule:"The optional module to be executed after deployment",postDeploymentModuleCalldata:"The data to be passed to the post deployment module",primaryContractDeployment:"Contains the needed parameter to deploy a contract. (`salt`, `fundingAmount`, `creationBytecode`)",secondaryContractDeployment:"Contains the needed parameter to deploy the secondary contract. (`fundingAmount`, `creationBytecode`, `addPrimaryContractAddress`, `extraConstructorParams`)"},returns:{primaryContractAddress:"The address of the primary contract.",secondaryContractAddress:"The address of the secondary contract."}},userdoc:{notice:"Contracts deployed. Contract Address: `primaryContractAddress`. Primary Contract Address: `primaryContractAddress`"}},"0x6a66a753":{sig:"deployERC1167Proxies((bytes32,uint256,address,bytes),(uint256,address,bytes,bool,bytes),address,bytes)",inputs:[{components:[{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256",name:"fundingAmount",type:"uint256"},{internalType:"address",name:"implementationContract",type:"address"},{internalType:"bytes",name:"initializationCalldata",type:"bytes"}],internalType:"struct ILSP23LinkedContractsFactory.PrimaryContractDeploymentInit",name:"primaryContractDeploymentInit",type:"tuple"},{components:[{internalType:"uint256",name:"fundingAmount",type:"uint256"},{internalType:"address",name:"implementationContract",type:"address"},{internalType:"bytes",name:"initializationCalldata",type:"bytes"},{internalType:"bool",name:"addPrimaryContractAddress",type:"bool"},{internalType:"bytes",name:"extraInitializationParams",type:"bytes"}],internalType:"struct ILSP23LinkedContractsFactory.SecondaryContractDeploymentInit",name:"secondaryContractDeploymentInit",type:"tuple"},{internalType:"address",name:"postDeploymentModule",type:"address"},{internalType:"bytes",name:"postDeploymentModuleCalldata",type:"bytes"}],name:"deployERC1167Proxies",outputs:[{internalType:"address",name:"primaryContractAddress",type:"address"},{internalType:"address",name:"secondaryContractAddress",type:"address"}],stateMutability:"payable",type:"function",devdoc:{details:"Deploys ERC1167 proxies of a primary contract and a secondary linked contract",params:{postDeploymentModule:"The optional module to be executed after deployment.",postDeploymentModuleCalldata:"The data to be passed to the post deployment module.",primaryContractDeploymentInit:"Contains the needed parameters to deploy a proxy contract. (`salt`, `fundingAmount`, `implementationContract`, `initializationCalldata`)",secondaryContractDeploymentInit:"Contains the needed parameters to deploy the secondary proxy contract. (`fundingAmount`, `implementationContract`, `initializationCalldata`, `addPrimaryContractAddress`, `extraInitializationParams`)"},returns:{primaryContractAddress:"The address of the deployed primary contract proxy",secondaryContractAddress:"The address of the deployed secondary contract proxy"}},userdoc:{notice:"Contract proxies deployed. Primary Proxy Address: `primaryContractAddress`. Secondary Contract Proxy Address: `secondaryContractAddress`"}}},LSP26FollowerSystem:{"0x4dbf27cc":{sig:"follow(address)",inputs:[{internalType:"address",name:"addr",type:"address"}],name:"follow",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{addr:"The address to start following."}},userdoc:{notice:"Follow an specific address."}},"0xcf8711c8":{sig:"followBatch(address[])",inputs:[{internalType:"address[]",name:"addresses",type:"address[]"}],name:"followBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{addresses:"The list of addresses to follow."}},userdoc:{notice:"Follow a list of addresses."}},"0x30b3a890":{sig:"followerCount(address)",inputs:[{internalType:"address",name:"addr",type:"address"}],name:"followerCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{params:{addr:"The address whose followers count is requested."},returns:{_0:"The number of followers of `addr`."}},userdoc:{notice:"Get the number of followers for an address."}},"0x64548707":{sig:"followingCount(address)",inputs:[{internalType:"address",name:"addr",type:"address"}],name:"followingCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{params:{addr:"The address of the follower whose following count is requested."},returns:{_0:"The number of addresses that `addr` is following."}},userdoc:{notice:"Get the number of addresses an address is following."}},"0xb2a8d069":{sig:"getFollowersByIndex(address,uint256,uint256)",inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],name:"getFollowersByIndex",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{params:{addr:"The address whose followers are requested.",endIndex:"The end index of the range (exclusive).",startIndex:"The start index of the range (inclusive)."},returns:{_0:"An array of addresses that are following an addresses."}},userdoc:{notice:"Get the list of addresses that follow an address within a specified range."}},"0x5a39c581":{sig:"getFollowsByIndex(address,uint256,uint256)",inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],name:"getFollowsByIndex",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{params:{addr:"The address whose followed addresses are requested.",endIndex:"The end index of the range (exclusive).",startIndex:"The start index of the range (inclusive)."},returns:{_0:"An array of addresses followed by the given address."}},userdoc:{notice:"Get the list of addresses the given address is following within a specified range."}},"0x99ec3a42":{sig:"isFollowing(address,address)",inputs:[{internalType:"address",name:"follower",type:"address"},{internalType:"address",name:"addr",type:"address"}],name:"isFollowing",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{params:{addr:"The address being followed.",follower:"The address of the follower to check."},returns:{_0:"True if `follower` is following `addr`, false otherwise."}},userdoc:{notice:"Check if an address is following a specific address."}},"0x015a4ead":{sig:"unfollow(address)",inputs:[{internalType:"address",name:"addr",type:"address"}],name:"unfollow",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{addr:"The address to stop following."}},userdoc:{notice:"Unfollow a specific address."}},"0x8dd1e47e":{sig:"unfollowBatch(address[])",inputs:[{internalType:"address[]",name:"addresses",type:"address[]"}],name:"unfollowBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{addresses:"The list of addresses to unfollow."}},userdoc:{notice:"Unfollow a list of addresses."}}},LSP4DigitalAssetMetadata:{"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP4DigitalAssetMetadataInitAbstract:{"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP6KeyManager:{"0xffa1ad74":{sig:"VERSION()",inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",userdoc:{notice:"Contract version."}},"0x09c5eabe":{sig:"execute(bytes)",inputs:[{internalType:"bytes",name:"payload",type:"bytes"}],name:"execute",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{PermissionsVerified} event when the permissions related to `payload` have been verified successfully.",details:"Execute A `payload` on the linked {target} contract after having verified the permissions associated with the function being run. The `payload` MUST be a valid abi-encoded function call of one of the functions present in the linked {target}, otherwise the call will fail. The linked {target} will return some data on successful execution, or revert on failure.",params:{payload:"The abi-encoded function call to execute on the linked {target}."},returns:{_0:"The abi-decoded data returned by the function called on the linked {target}."}},userdoc:{notice:"Executing the following payload on the linked contract: `payload`"}},"0xbf0176ff":{sig:"executeBatch(uint256[],bytes[])",inputs:[{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"payloads",type:"bytes[]"}],name:"executeBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{PermissionsVerified} event for each permissions related to each `payload` that have been verified successfully.",details:"Same as {execute} but execute a batch of payloads (abi-encoded function calls) in a single transaction.",params:{payloads:"An array of abi-encoded function calls to execute successively on the linked {target}.",values:"An array of amount of native tokens to be transferred for each `payload`."},returns:{_0:"An array of abi-decoded data returned by the functions called on the linked {target}."}},userdoc:{notice:"Executing the following batch of payloads and sensind on the linked contract. - payloads: `payloads` - values transferred for each payload: `values`"}},"0x4c8a4e74":{sig:"executeRelayCall(bytes,uint256,uint256,bytes)",inputs:[{internalType:"bytes",name:"signature",type:"bytes"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"validityTimestamps",type:"uint256"},{internalType:"bytes",name:"payload",type:"bytes"}],name:"executeRelayCall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{PermissionsVerified} event when the permissions related to `payload` have been verified successfully.","custom:hint":'If you are looking to learn how to sign and execute relay transactions via the Key Manager, see our Javascript step by step guide [_"Execute Relay Transactions"_](../../../learn/universal-profile/key-manager/execute-relay-transactions.md). See the LSP6 Standard page for more details on how to [generate a valid signature for Execute Relay Call](../../../standards/universal-profile/lsp6-key-manager.md#how-to-sign-relay-transactions).',details:"Allows any address (executor) to execute a payload (= abi-encoded function call), given they have a valid signature from a signer address and a valid `nonce` for this signer. The signature MUST be generated according to the signature format defined by the LSP25 standard. The signer that generated the `signature` MUST be a controller with some permissions on the linked {target}. The `payload` will be executed on the {target} contract once the LSP25 signature and the permissions of the signer have been verified.",params:{nonce:"The nonce of the address that signed the calldata (in a specific `_channel`), obtained via {getNonce}. Used to prevent replay attack.",payload:"The abi-encoded function call to execute.",signature:"A 65 bytes long signature for a meta transaction according to LSP25.",validityTimestamps:'Two `uint128` timestamps concatenated together that describes when the relay transaction is valid "from" (left `uint128`) and "until" as a deadline (right `uint128`).'},returns:{_0:"The data being returned by the function executed."}},userdoc:{notice:"Executing the following payload given the nonce `nonce` and signature `signature`. Payload: `payload`"}},"0xa20856a5":{sig:"executeRelayCallBatch(bytes[],uint256[],uint256[],uint256[],bytes[])",inputs:[{internalType:"bytes[]",name:"signatures",type:"bytes[]"},{internalType:"uint256[]",name:"nonces",type:"uint256[]"},{internalType:"uint256[]",name:"validityTimestamps",type:"uint256[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"payloads",type:"bytes[]"}],name:"executeRelayCallBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{"custom:requirements":"- the length of `signatures`, `nonces`, `validityTimestamps`, `values` and `payloads` MUST be the same. - the value sent to this function (`msg.value`) MUST be equal to the sum of all `values` in the batch. There should not be any excess value sent to this function.",details:"Same as {executeRelayCall} but execute a batch of signed calldata payloads (abi-encoded function calls) in a single transaction. The `signatures` can be from multiple controllers, not necessarily the same controller, as long as each of these controllers that signed have the right permissions related to the calldata `payload` they signed.",params:{nonces:"An array of nonces of the addresses that signed the calldata payloads (in specific channels). Obtained via {getNonce}. Used to prevent replay attack.",payloads:"An array of abi-encoded function calls to be executed successively.",signatures:"An array of 65 bytes long signatures for meta transactions according to LSP25.",validityTimestamps:'An array of two `uint128` concatenated timestamps that describe when the relay transaction is valid "from" (left `uint128`) and "until" (right `uint128`).',values:"An array of amount of native tokens to be transferred for each calldata `payload`."},returns:{_0:"An array of abi-decoded data returned by the functions executed."}},userdoc:{notice:"Executing a batch of relay calls (= meta-transactions)."}},"0xb44581d9":{sig:"getNonce(address,uint128)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"uint128",name:"channelId",type:"uint128"}],name:"getNonce",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{"custom:hint":'A signer can choose its channel number arbitrarily. The recommended practice is to: - use `channelId == 0` for transactions for which the ordering of execution matters.abi _Example: you have two transactions A and B, and transaction A must be executed first and complete successfully before transaction B should be executed)._ - use any other `channelId` number for transactions that you want to be order independent (out-of-order execution, execution _"in parallel"_). _Example: you have two transactions A and B. You want transaction B to be executed a) without having to wait for transaction A to complete, or b) regardless if transaction A completed successfully or not.',"custom:info":"For more details, see the internal function {`_getNonce`}.",details:"Get the nonce for a specific `from` address that can be used for signing relay transactions via {executeRelayCall}.",params:{channelId:"The channel id that the signer wants to use for executing the transaction.",from:"The address of the signer of the transaction."},returns:{_0:"The current nonce on a specific `channelId`."}},userdoc:{notice:"Reading the latest nonce of address `from` in the channel ID `channelId`."}},"0x1626ba7e":{sig:"isValidSignature(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataHash",type:"bytes32"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"isValidSignature",outputs:[{internalType:"bytes4",name:"returnedStatus",type:"bytes4"}],stateMutability:"view",type:"function",devdoc:{"custom:warning":"This function does not enforce by default the inclusion of the address of this contract in the signature digest. It is recommended that protocols or applications using this contract include the targeted address (= this contract) in the data to sign. To ensure that a signature is valid for a specific LSP6KeyManager and prevent signatures from the same EOA to be replayed across different LSP6KeyManager.",details:"Checks if a signature was signed by a controller that has the permission `SIGN`. If the signer is a controller with the permission `SIGN`, it will return the ERC1271 success value.",params:{hash:"Hash of the data to be signed",signature:"Signature byte array associated with _data"},returns:{returnedStatus:"`0x1626ba7e` on success, or `0xffffffff` on failure."}}},"0xde928f14":{sig:"lsp20VerifyCall(address,address,address,uint256,bytes)",inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"targetContract",type:"address"},{internalType:"address",name:"caller",type:"address"},{internalType:"uint256",name:"msgValue",type:"uint256"},{internalType:"bytes",name:"callData",type:"bytes"}],name:"lsp20VerifyCall",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:hint":'This function can call by any other address than the {`target`}. This allows to verify permissions in a _"read-only"_ manner. Anyone can call this function to verify if the `caller` has the right permissions to perform the abi-encoded function call `data` on the {`target`} contract (while sending `msgValue` alongside the call). If the permissions have been verified successfully and `caller` is authorized, one of the following two LSP20 success value will be returned:  - `0x1a238000`: LSP20 success value **without** post verification (last byte is `0x00`).  - `0x1a238001`: LSP20 success value **with** post-verification (last byte is `0x01`).',params:{callData:"The calldata sent by the caller to the msg.sender",caller:"The address who called the function on the `target` contract.",requestor:"The address that requested to make the call to `target`.",target:"The address of the contract that implements the `LSP20CallVerification` interface.",value:"The value sent by the caller to the function called on the msg.sender"},returns:{_0:"MUST return the first 3 bytes of `lsp20VerifyCall(address,uint256,bytes)` function selector if the call to the function is allowed, concatenated with a byte that determines if the lsp20VerifyCallResult function should be called after the original function call. The byte that invoke the lsp20VerifyCallResult function is strictly `0x01`."}}},"0xd3fc45d3":{sig:"lsp20VerifyCallResult(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"bytes",name:"",type:"bytes"}],name:"lsp20VerifyCallResult",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",devdoc:{params:{callHash:"The keccak256 hash of the parameters of {lsp20VerifyCall} concatenated",callResult:"The value result of the function called on the msg.sender"},returns:{_0:"MUST return the lsp20VerifyCallResult function selector if the call to the function is allowed"}}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xd4b83992":{sig:"target()",inputs:[],name:"target",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Get The address of the contract linked to this Key Manager.",returns:{_0:"The address of the linked contract"}}}},LSP6KeyManagerInit:{"0xffa1ad74":{sig:"VERSION()",inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",userdoc:{notice:"Contract version."}},"0x09c5eabe":{sig:"execute(bytes)",inputs:[{internalType:"bytes",name:"payload",type:"bytes"}],name:"execute",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{PermissionsVerified} event when the permissions related to `payload` have been verified successfully.",details:"Execute A `payload` on the linked {target} contract after having verified the permissions associated with the function being run. The `payload` MUST be a valid abi-encoded function call of one of the functions present in the linked {target}, otherwise the call will fail. The linked {target} will return some data on successful execution, or revert on failure.",params:{payload:"The abi-encoded function call to execute on the linked {target}."},returns:{_0:"The abi-decoded data returned by the function called on the linked {target}."}},userdoc:{notice:"Executing the following payload on the linked contract: `payload`"}},"0xbf0176ff":{sig:"executeBatch(uint256[],bytes[])",inputs:[{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"payloads",type:"bytes[]"}],name:"executeBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{PermissionsVerified} event for each permissions related to each `payload` that have been verified successfully.",details:"Same as {execute} but execute a batch of payloads (abi-encoded function calls) in a single transaction.",params:{payloads:"An array of abi-encoded function calls to execute successively on the linked {target}.",values:"An array of amount of native tokens to be transferred for each `payload`."},returns:{_0:"An array of abi-decoded data returned by the functions called on the linked {target}."}},userdoc:{notice:"Executing the following batch of payloads and sensind on the linked contract. - payloads: `payloads` - values transferred for each payload: `values`"}},"0x4c8a4e74":{sig:"executeRelayCall(bytes,uint256,uint256,bytes)",inputs:[{internalType:"bytes",name:"signature",type:"bytes"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"validityTimestamps",type:"uint256"},{internalType:"bytes",name:"payload",type:"bytes"}],name:"executeRelayCall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{PermissionsVerified} event when the permissions related to `payload` have been verified successfully.","custom:hint":'If you are looking to learn how to sign and execute relay transactions via the Key Manager, see our Javascript step by step guide [_"Execute Relay Transactions"_](../../../learn/universal-profile/key-manager/execute-relay-transactions.md). See the LSP6 Standard page for more details on how to [generate a valid signature for Execute Relay Call](../../../standards/universal-profile/lsp6-key-manager.md#how-to-sign-relay-transactions).',details:"Allows any address (executor) to execute a payload (= abi-encoded function call), given they have a valid signature from a signer address and a valid `nonce` for this signer. The signature MUST be generated according to the signature format defined by the LSP25 standard. The signer that generated the `signature` MUST be a controller with some permissions on the linked {target}. The `payload` will be executed on the {target} contract once the LSP25 signature and the permissions of the signer have been verified.",params:{nonce:"The nonce of the address that signed the calldata (in a specific `_channel`), obtained via {getNonce}. Used to prevent replay attack.",payload:"The abi-encoded function call to execute.",signature:"A 65 bytes long signature for a meta transaction according to LSP25.",validityTimestamps:'Two `uint128` timestamps concatenated together that describes when the relay transaction is valid "from" (left `uint128`) and "until" as a deadline (right `uint128`).'},returns:{_0:"The data being returned by the function executed."}},userdoc:{notice:"Executing the following payload given the nonce `nonce` and signature `signature`. Payload: `payload`"}},"0xa20856a5":{sig:"executeRelayCallBatch(bytes[],uint256[],uint256[],uint256[],bytes[])",inputs:[{internalType:"bytes[]",name:"signatures",type:"bytes[]"},{internalType:"uint256[]",name:"nonces",type:"uint256[]"},{internalType:"uint256[]",name:"validityTimestamps",type:"uint256[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"payloads",type:"bytes[]"}],name:"executeRelayCallBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{"custom:requirements":"- the length of `signatures`, `nonces`, `validityTimestamps`, `values` and `payloads` MUST be the same. - the value sent to this function (`msg.value`) MUST be equal to the sum of all `values` in the batch. There should not be any excess value sent to this function.",details:"Same as {executeRelayCall} but execute a batch of signed calldata payloads (abi-encoded function calls) in a single transaction. The `signatures` can be from multiple controllers, not necessarily the same controller, as long as each of these controllers that signed have the right permissions related to the calldata `payload` they signed.",params:{nonces:"An array of nonces of the addresses that signed the calldata payloads (in specific channels). Obtained via {getNonce}. Used to prevent replay attack.",payloads:"An array of abi-encoded function calls to be executed successively.",signatures:"An array of 65 bytes long signatures for meta transactions according to LSP25.",validityTimestamps:'An array of two `uint128` concatenated timestamps that describe when the relay transaction is valid "from" (left `uint128`) and "until" (right `uint128`).',values:"An array of amount of native tokens to be transferred for each calldata `payload`."},returns:{_0:"An array of abi-decoded data returned by the functions executed."}},userdoc:{notice:"Executing a batch of relay calls (= meta-transactions)."}},"0xb44581d9":{sig:"getNonce(address,uint128)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"uint128",name:"channelId",type:"uint128"}],name:"getNonce",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{"custom:hint":'A signer can choose its channel number arbitrarily. The recommended practice is to: - use `channelId == 0` for transactions for which the ordering of execution matters.abi _Example: you have two transactions A and B, and transaction A must be executed first and complete successfully before transaction B should be executed)._ - use any other `channelId` number for transactions that you want to be order independent (out-of-order execution, execution _"in parallel"_). _Example: you have two transactions A and B. You want transaction B to be executed a) without having to wait for transaction A to complete, or b) regardless if transaction A completed successfully or not.',"custom:info":"For more details, see the internal function {`_getNonce`}.",details:"Get the nonce for a specific `from` address that can be used for signing relay transactions via {executeRelayCall}.",params:{channelId:"The channel id that the signer wants to use for executing the transaction.",from:"The address of the signer of the transaction."},returns:{_0:"The current nonce on a specific `channelId`."}},userdoc:{notice:"Reading the latest nonce of address `from` in the channel ID `channelId`."}},"0xc4d66de8":{sig:"initialize(address)",inputs:[{internalType:"address",name:"target_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Initialise a LSP6KeyManager and set the `target_` address in the contract storage, making this Key Manager linked to this `target_` contract.",params:{target_:"The address of the contract to control and forward calldata payloads to."}},userdoc:{notice:"Initializing a LSP6KeyManagerInit linked to contract at address `target_`."}},"0x1626ba7e":{sig:"isValidSignature(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataHash",type:"bytes32"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"isValidSignature",outputs:[{internalType:"bytes4",name:"returnedStatus",type:"bytes4"}],stateMutability:"view",type:"function",devdoc:{"custom:warning":"This function does not enforce by default the inclusion of the address of this contract in the signature digest. It is recommended that protocols or applications using this contract include the targeted address (= this contract) in the data to sign. To ensure that a signature is valid for a specific LSP6KeyManager and prevent signatures from the same EOA to be replayed across different LSP6KeyManager.",details:"Checks if a signature was signed by a controller that has the permission `SIGN`. If the signer is a controller with the permission `SIGN`, it will return the ERC1271 success value.",params:{hash:"Hash of the data to be signed",signature:"Signature byte array associated with _data"},returns:{returnedStatus:"`0x1626ba7e` on success, or `0xffffffff` on failure."}}},"0xde928f14":{sig:"lsp20VerifyCall(address,address,address,uint256,bytes)",inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"targetContract",type:"address"},{internalType:"address",name:"caller",type:"address"},{internalType:"uint256",name:"msgValue",type:"uint256"},{internalType:"bytes",name:"callData",type:"bytes"}],name:"lsp20VerifyCall",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:hint":'This function can call by any other address than the {`target`}. This allows to verify permissions in a _"read-only"_ manner. Anyone can call this function to verify if the `caller` has the right permissions to perform the abi-encoded function call `data` on the {`target`} contract (while sending `msgValue` alongside the call). If the permissions have been verified successfully and `caller` is authorized, one of the following two LSP20 success value will be returned:  - `0x1a238000`: LSP20 success value **without** post verification (last byte is `0x00`).  - `0x1a238001`: LSP20 success value **with** post-verification (last byte is `0x01`).',params:{callData:"The calldata sent by the caller to the msg.sender",caller:"The address who called the function on the `target` contract.",requestor:"The address that requested to make the call to `target`.",target:"The address of the contract that implements the `LSP20CallVerification` interface.",value:"The value sent by the caller to the function called on the msg.sender"},returns:{_0:"MUST return the first 3 bytes of `lsp20VerifyCall(address,uint256,bytes)` function selector if the call to the function is allowed, concatenated with a byte that determines if the lsp20VerifyCallResult function should be called after the original function call. The byte that invoke the lsp20VerifyCallResult function is strictly `0x01`."}}},"0xd3fc45d3":{sig:"lsp20VerifyCallResult(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"bytes",name:"",type:"bytes"}],name:"lsp20VerifyCallResult",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",devdoc:{params:{callHash:"The keccak256 hash of the parameters of {lsp20VerifyCall} concatenated",callResult:"The value result of the function called on the msg.sender"},returns:{_0:"MUST return the lsp20VerifyCallResult function selector if the call to the function is allowed"}}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xd4b83992":{sig:"target()",inputs:[],name:"target",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Get The address of the contract linked to this Key Manager.",returns:{_0:"The address of the linked contract"}}}},LSP7DigitalAsset:{"0xb49506fd":{sig:"authorizeOperator(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to use the {increaseAllowance} and {decreaseAllowance} functions. For more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",details:"Sets an `amount` of tokens that an `operator` has access from the caller's balance (allowance). See {authorizedAmountFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{amount:"The allowance amount of tokens operator has access to.",operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1."}}},"0x65aeaa95":{sig:"authorizedAmountFor(address,address)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"}],name:"authorizedAmountFor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners.",params:{operator:"The operator's address to query the authorized amount for.",tokenOwner:"The token owner that `operator` has allowance on."},returns:{_0:"The amount of tokens the `operator`'s address has access on the `tokenOwner`'s balance."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of tokens owned by `tokenOwner`. If the token is divisible (the {decimals} function returns `18`), the amount returned should be divided by 1e18 to get a better picture of the actual balance of the `tokenOwner`. _Example:_ ``` balanceOf(someAddress) -> 42_000_000_000_000_000_000 / 1e18 = 42 tokens ```",params:{tokenOwner:"The address of the token holder to query the balance for."},returns:{_0:"The amount of tokens owned by `tokenOwner`."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x313ce567":{sig:"decimals()",inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of decimals used to get its user representation. If the asset contract has been set to be non-divisible via the `isNonDivisible_` parameter in the `constructor`, the decimals returned will be `0`. Otherwise `18` is the common value.",returns:{_0:"the number of decimals. If `0` is returned, the asset is non-divisible."}}},"0x78381670":{sig:"decreaseAllowance(address,address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"uint256",name:"subtractedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"decreaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The operator to decrease allowance for `msg.sender`",subtractedAmount:"The amount to decrease by in the operator's allowance.",tokenOwner:"The address of the token owner."}},userdoc:{notice:"Decrease the allowance of `operator` by -`subtractedAmount`"}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0xd72fc29a":{sig:"getOperatorsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn on behalf of `tokenOwner`.",params:{tokenOwner:"The token owner to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn tokens on behalf of `tokenOwner`."}}},"0x2bc1da82":{sig:"increaseAllowance(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"addedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"increaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{addedAmount:"The additional amount to add on top of the current operator's allowance",operator:"The operator to increase the allowance for `msg.sender`"}},userdoc:{notice:"Increase the allowance of `operator` by +`addedAmount`"}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0x30d0dc37":{sig:"revokeOperator(address,address,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Enables `tokenOwner` to remove `operator` for its tokens, disallowing it to send any amount of tokens on its behalf. This function also allows the `operator` to remove itself if it is the caller of this function",params:{notify:"Boolean indicating whether to notify the operator or not.",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenOwner:"The address of the token owner."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x760d9bba":{sig:"transfer(address,address,uint256,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers an `amount` of tokens from the `from` address to the `to` address and notify both sender and recipients via the LSP1 {`universalReceiver(...)`} function. If the tokens are transferred by an operator on behalf of a token holder, the allowance for the operator will be decreased by `amount` once the token transfer has been completed (See {authorizedAmountFor}).",params:{amount:"The amount of tokens to transfer.",data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The sender address.",to:"The recipient address."}}},"0x2d7667c9":{sig:"transferBatch(address[],address[],uint256[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"uint256[]",name:"amount",type:"uint256[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Same as {`transfer(...)`} but transfer multiple tokens based on the arrays of `from`, `to`, `amount`.",params:{amount:"An array of amount of tokens to transfer for each `from -> to` transfer.",data:"An array of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",force:"For each transfer, when set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"An array of sending addresses.",to:"An array of receiving addresses."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP7DigitalAssetInitAbstract:{"0xb49506fd":{sig:"authorizeOperator(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to use the {increaseAllowance} and {decreaseAllowance} functions. For more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",details:"Sets an `amount` of tokens that an `operator` has access from the caller's balance (allowance). See {authorizedAmountFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{amount:"The allowance amount of tokens operator has access to.",operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1."}}},"0x65aeaa95":{sig:"authorizedAmountFor(address,address)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"}],name:"authorizedAmountFor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners.",params:{operator:"The operator's address to query the authorized amount for.",tokenOwner:"The token owner that `operator` has allowance on."},returns:{_0:"The amount of tokens the `operator`'s address has access on the `tokenOwner`'s balance."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of tokens owned by `tokenOwner`. If the token is divisible (the {decimals} function returns `18`), the amount returned should be divided by 1e18 to get a better picture of the actual balance of the `tokenOwner`. _Example:_ ``` balanceOf(someAddress) -> 42_000_000_000_000_000_000 / 1e18 = 42 tokens ```",params:{tokenOwner:"The address of the token holder to query the balance for."},returns:{_0:"The amount of tokens owned by `tokenOwner`."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x313ce567":{sig:"decimals()",inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of decimals used to get its user representation. If the asset contract has been set to be non-divisible via the `isNonDivisible_` parameter in the `constructor`, the decimals returned will be `0`. Otherwise `18` is the common value.",returns:{_0:"the number of decimals. If `0` is returned, the asset is non-divisible."}}},"0x78381670":{sig:"decreaseAllowance(address,address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"uint256",name:"subtractedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"decreaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The operator to decrease allowance for `msg.sender`",subtractedAmount:"The amount to decrease by in the operator's allowance.",tokenOwner:"The address of the token owner."}},userdoc:{notice:"Decrease the allowance of `operator` by -`subtractedAmount`"}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0xd72fc29a":{sig:"getOperatorsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn on behalf of `tokenOwner`.",params:{tokenOwner:"The token owner to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn tokens on behalf of `tokenOwner`."}}},"0x2bc1da82":{sig:"increaseAllowance(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"addedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"increaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{addedAmount:"The additional amount to add on top of the current operator's allowance",operator:"The operator to increase the allowance for `msg.sender`"}},userdoc:{notice:"Increase the allowance of `operator` by +`addedAmount`"}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0x30d0dc37":{sig:"revokeOperator(address,address,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Enables `tokenOwner` to remove `operator` for its tokens, disallowing it to send any amount of tokens on its behalf. This function also allows the `operator` to remove itself if it is the caller of this function",params:{notify:"Boolean indicating whether to notify the operator or not.",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenOwner:"The address of the token owner."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x760d9bba":{sig:"transfer(address,address,uint256,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers an `amount` of tokens from the `from` address to the `to` address and notify both sender and recipients via the LSP1 {`universalReceiver(...)`} function. If the tokens are transferred by an operator on behalf of a token holder, the allowance for the operator will be decreased by `amount` once the token transfer has been completed (See {authorizedAmountFor}).",params:{amount:"The amount of tokens to transfer.",data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The sender address.",to:"The recipient address."}}},"0x2d7667c9":{sig:"transferBatch(address[],address[],uint256[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"uint256[]",name:"amount",type:"uint256[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Same as {`transfer(...)`} but transfer multiple tokens based on the arrays of `from`, `to`, `amount`.",params:{amount:"An array of amount of tokens to transfer for each `from -> to` transfer.",data:"An array of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",force:"For each transfer, when set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"An array of sending addresses.",to:"An array of receiving addresses."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP7CappedSupply:{"0xb49506fd":{sig:"authorizeOperator(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to use the {increaseAllowance} and {decreaseAllowance} functions. For more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",details:"Sets an `amount` of tokens that an `operator` has access from the caller's balance (allowance). See {authorizedAmountFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{amount:"The allowance amount of tokens operator has access to.",operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1."}}},"0x65aeaa95":{sig:"authorizedAmountFor(address,address)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"}],name:"authorizedAmountFor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners.",params:{operator:"The operator's address to query the authorized amount for.",tokenOwner:"The token owner that `operator` has allowance on."},returns:{_0:"The amount of tokens the `operator`'s address has access on the `tokenOwner`'s balance."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of tokens owned by `tokenOwner`. If the token is divisible (the {decimals} function returns `18`), the amount returned should be divided by 1e18 to get a better picture of the actual balance of the `tokenOwner`. _Example:_ ``` balanceOf(someAddress) -> 42_000_000_000_000_000_000 / 1e18 = 42 tokens ```",params:{tokenOwner:"The address of the token holder to query the balance for."},returns:{_0:"The amount of tokens owned by `tokenOwner`."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x313ce567":{sig:"decimals()",inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of decimals used to get its user representation. If the asset contract has been set to be non-divisible via the `isNonDivisible_` parameter in the `constructor`, the decimals returned will be `0`. Otherwise `18` is the common value.",returns:{_0:"the number of decimals. If `0` is returned, the asset is non-divisible."}}},"0x78381670":{sig:"decreaseAllowance(address,address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"uint256",name:"subtractedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"decreaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The operator to decrease allowance for `msg.sender`",subtractedAmount:"The amount to decrease by in the operator's allowance.",tokenOwner:"The address of the token owner."}},userdoc:{notice:"Decrease the allowance of `operator` by -`subtractedAmount`"}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0xd72fc29a":{sig:"getOperatorsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn on behalf of `tokenOwner`.",params:{tokenOwner:"The token owner to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn tokens on behalf of `tokenOwner`."}}},"0x2bc1da82":{sig:"increaseAllowance(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"addedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"increaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{addedAmount:"The additional amount to add on top of the current operator's allowance",operator:"The operator to increase the allowance for `msg.sender`"}},userdoc:{notice:"Increase the allowance of `operator` by +`addedAmount`"}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0x30d0dc37":{sig:"revokeOperator(address,address,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Enables `tokenOwner` to remove `operator` for its tokens, disallowing it to send any amount of tokens on its behalf. This function also allows the `operator` to remove itself if it is the caller of this function",params:{notify:"Boolean indicating whether to notify the operator or not.",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenOwner:"The address of the token owner."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0x52058d8a":{sig:"tokenSupplyCap()",inputs:[],name:"tokenSupplyCap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the maximum number of tokens that can exist to circulate. Once {totalSupply} reaches reaches {totalSupplyCap}, it is not possible to mint more tokens.",returns:{_0:"The maximum number of tokens that can exist in the contract."}},userdoc:{notice:"The maximum supply amount of tokens allowed to exist is `_TOKEN_SUPPLY_CAP`."}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x760d9bba":{sig:"transfer(address,address,uint256,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers an `amount` of tokens from the `from` address to the `to` address and notify both sender and recipients via the LSP1 {`universalReceiver(...)`} function. If the tokens are transferred by an operator on behalf of a token holder, the allowance for the operator will be decreased by `amount` once the token transfer has been completed (See {authorizedAmountFor}).",params:{amount:"The amount of tokens to transfer.",data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The sender address.",to:"The recipient address."}}},"0x2d7667c9":{sig:"transferBatch(address[],address[],uint256[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"uint256[]",name:"amount",type:"uint256[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Same as {`transfer(...)`} but transfer multiple tokens based on the arrays of `from`, `to`, `amount`.",params:{amount:"An array of amount of tokens to transfer for each `from -> to` transfer.",data:"An array of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",force:"For each transfer, when set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"An array of sending addresses.",to:"An array of receiving addresses."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP7CappedSupplyInitAbstract:{"0xb49506fd":{sig:"authorizeOperator(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to use the {increaseAllowance} and {decreaseAllowance} functions. For more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",details:"Sets an `amount` of tokens that an `operator` has access from the caller's balance (allowance). See {authorizedAmountFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{amount:"The allowance amount of tokens operator has access to.",operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1."}}},"0x65aeaa95":{sig:"authorizedAmountFor(address,address)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"}],name:"authorizedAmountFor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners.",params:{operator:"The operator's address to query the authorized amount for.",tokenOwner:"The token owner that `operator` has allowance on."},returns:{_0:"The amount of tokens the `operator`'s address has access on the `tokenOwner`'s balance."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of tokens owned by `tokenOwner`. If the token is divisible (the {decimals} function returns `18`), the amount returned should be divided by 1e18 to get a better picture of the actual balance of the `tokenOwner`. _Example:_ ``` balanceOf(someAddress) -> 42_000_000_000_000_000_000 / 1e18 = 42 tokens ```",params:{tokenOwner:"The address of the token holder to query the balance for."},returns:{_0:"The amount of tokens owned by `tokenOwner`."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x313ce567":{sig:"decimals()",inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of decimals used to get its user representation. If the asset contract has been set to be non-divisible via the `isNonDivisible_` parameter in the `constructor`, the decimals returned will be `0`. Otherwise `18` is the common value.",returns:{_0:"the number of decimals. If `0` is returned, the asset is non-divisible."}}},"0x78381670":{sig:"decreaseAllowance(address,address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"uint256",name:"subtractedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"decreaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The operator to decrease allowance for `msg.sender`",subtractedAmount:"The amount to decrease by in the operator's allowance.",tokenOwner:"The address of the token owner."}},userdoc:{notice:"Decrease the allowance of `operator` by -`subtractedAmount`"}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0xd72fc29a":{sig:"getOperatorsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn on behalf of `tokenOwner`.",params:{tokenOwner:"The token owner to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn tokens on behalf of `tokenOwner`."}}},"0x2bc1da82":{sig:"increaseAllowance(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"addedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"increaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{addedAmount:"The additional amount to add on top of the current operator's allowance",operator:"The operator to increase the allowance for `msg.sender`"}},userdoc:{notice:"Increase the allowance of `operator` by +`addedAmount`"}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0x30d0dc37":{sig:"revokeOperator(address,address,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Enables `tokenOwner` to remove `operator` for its tokens, disallowing it to send any amount of tokens on its behalf. This function also allows the `operator` to remove itself if it is the caller of this function",params:{notify:"Boolean indicating whether to notify the operator or not.",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenOwner:"The address of the token owner."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0x52058d8a":{sig:"tokenSupplyCap()",inputs:[],name:"tokenSupplyCap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the maximum number of tokens that can exist to circulate. Once {totalSupply} reaches reaches {totalSupplyCap}, it is not possible to mint more tokens.",returns:{_0:"The maximum number of tokens that can exist in the contract."}},userdoc:{notice:"The maximum supply amount of tokens allowed to exist is `_tokenSupplyCap`."}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x760d9bba":{sig:"transfer(address,address,uint256,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers an `amount` of tokens from the `from` address to the `to` address and notify both sender and recipients via the LSP1 {`universalReceiver(...)`} function. If the tokens are transferred by an operator on behalf of a token holder, the allowance for the operator will be decreased by `amount` once the token transfer has been completed (See {authorizedAmountFor}).",params:{amount:"The amount of tokens to transfer.",data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The sender address.",to:"The recipient address."}}},"0x2d7667c9":{sig:"transferBatch(address[],address[],uint256[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"uint256[]",name:"amount",type:"uint256[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Same as {`transfer(...)`} but transfer multiple tokens based on the arrays of `from`, `to`, `amount`.",params:{amount:"An array of amount of tokens to transfer for each `from -> to` transfer.",data:"An array of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",force:"For each transfer, when set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"An array of sending addresses.",to:"An array of receiving addresses."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP7Votes:{"0x4bf5d7e9":{sig:"CLOCK_MODE()",inputs:[],name:"CLOCK_MODE",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",devdoc:{details:"Description of the clock"}},"0x3644e515":{sig:"DOMAIN_SEPARATOR()",inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"0xb49506fd":{sig:"authorizeOperator(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to use the {increaseAllowance} and {decreaseAllowance} functions. For more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",details:"Sets an `amount` of tokens that an `operator` has access from the caller's balance (allowance). See {authorizedAmountFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{amount:"The allowance amount of tokens operator has access to.",operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1."}}},"0x65aeaa95":{sig:"authorizedAmountFor(address,address)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"}],name:"authorizedAmountFor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners.",params:{operator:"The operator's address to query the authorized amount for.",tokenOwner:"The token owner that `operator` has allowance on."},returns:{_0:"The amount of tokens the `operator`'s address has access on the `tokenOwner`'s balance."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of tokens owned by `tokenOwner`. If the token is divisible (the {decimals} function returns `18`), the amount returned should be divided by 1e18 to get a better picture of the actual balance of the `tokenOwner`. _Example:_ ``` balanceOf(someAddress) -> 42_000_000_000_000_000_000 / 1e18 = 42 tokens ```",params:{tokenOwner:"The address of the token holder to query the balance for."},returns:{_0:"The amount of tokens owned by `tokenOwner`."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0xf1127ed8":{sig:"checkpoints(address,uint32)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint32",name:"pos",type:"uint32"}],name:"checkpoints",outputs:[{components:[{internalType:"uint32",name:"fromBlock",type:"uint32"},{internalType:"uint224",name:"votes",type:"uint224"}],internalType:"struct LSP7Votes.Checkpoint",name:"",type:"tuple"}],stateMutability:"view",type:"function",devdoc:{details:"Get the `pos`-th checkpoint for `account`."}},"0x91ddadf4":{sig:"clock()",inputs:[],name:"clock",outputs:[{internalType:"uint48",name:"",type:"uint48"}],stateMutability:"view",type:"function",devdoc:{details:"Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting)."}},"0x313ce567":{sig:"decimals()",inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of decimals used to get its user representation. If the asset contract has been set to be non-divisible via the `isNonDivisible_` parameter in the `constructor`, the decimals returned will be `0`. Otherwise `18` is the common value.",returns:{_0:"the number of decimals. If `0` is returned, the asset is non-divisible."}}},"0x78381670":{sig:"decreaseAllowance(address,address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"uint256",name:"subtractedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"decreaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The operator to decrease allowance for `msg.sender`",subtractedAmount:"The amount to decrease by in the operator's allowance.",tokenOwner:"The address of the token owner."}},userdoc:{notice:"Decrease the allowance of `operator` by -`subtractedAmount`"}},"0x5c19a95c":{sig:"delegate(address)",inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegate",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Delegate votes from the sender to `delegatee`."}},"0xc3cda520":{sig:"delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)",inputs:[{internalType:"address",name:"delegatee",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"delegateBySig",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Delegates votes from signer to `delegatee`"}},"0x587cde1e":{sig:"delegates(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"delegates",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Get the address `account` is currently delegating to."}},"0x84b0196e":{sig:"eip712Domain()",inputs:[],name:"eip712Domain",outputs:[{internalType:"bytes1",name:"fields",type:"bytes1"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"version",type:"string"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"verifyingContract",type:"address"},{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256[]",name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function",devdoc:{details:"See {EIP-5267}. _Available since v4.9._"}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0xd72fc29a":{sig:"getOperatorsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn on behalf of `tokenOwner`.",params:{tokenOwner:"The token owner to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn tokens on behalf of `tokenOwner`."}}},"0x8e539e8c":{sig:"getPastTotalSupply(uint256)",inputs:[{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastTotalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{"custom:requirements":"- `timepoint` must be in the past",details:"Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances. It is NOT the sum of all the delegated votes!"}},"0x3a46b1a8":{sig:"getPastVotes(address,uint256)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{"custom:requirements":"- `timepoint` must be in the past",details:"Retrieve the number of votes for `account` at the end of `timepoint`."}},"0x9ab24eb0":{sig:"getVotes(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"getVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Gets the current votes balance for `account`"}},"0x2bc1da82":{sig:"increaseAllowance(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"addedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"increaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{addedAmount:"The additional amount to add on top of the current operator's allowance",operator:"The operator to increase the allowance for `msg.sender`"}},userdoc:{notice:"Increase the allowance of `operator` by +`addedAmount`"}},"0x7ecebe00":{sig:"nonces(address)",inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Reads the current nonce"}},"0x6fcfff45":{sig:"numCheckpoints(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"numCheckpoints",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",devdoc:{details:"Get number of checkpoints for `account`."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0x30d0dc37":{sig:"revokeOperator(address,address,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Enables `tokenOwner` to remove `operator` for its tokens, disallowing it to send any amount of tokens on its behalf. This function also allows the `operator` to remove itself if it is the caller of this function",params:{notify:"Boolean indicating whether to notify the operator or not.",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenOwner:"The address of the token owner."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x760d9bba":{sig:"transfer(address,address,uint256,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers an `amount` of tokens from the `from` address to the `to` address and notify both sender and recipients via the LSP1 {`universalReceiver(...)`} function. If the tokens are transferred by an operator on behalf of a token holder, the allowance for the operator will be decreased by `amount` once the token transfer has been completed (See {authorizedAmountFor}).",params:{amount:"The amount of tokens to transfer.",data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The sender address.",to:"The recipient address."}}},"0x2d7667c9":{sig:"transferBatch(address[],address[],uint256[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"uint256[]",name:"amount",type:"uint256[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Same as {`transfer(...)`} but transfer multiple tokens based on the arrays of `from`, `to`, `amount`.",params:{amount:"An array of amount of tokens to transfer for each `from -> to` transfer.",data:"An array of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",force:"For each transfer, when set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"An array of sending addresses.",to:"An array of receiving addresses."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP7Mintable:{"0xb49506fd":{sig:"authorizeOperator(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to use the {increaseAllowance} and {decreaseAllowance} functions. For more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",details:"Sets an `amount` of tokens that an `operator` has access from the caller's balance (allowance). See {authorizedAmountFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{amount:"The allowance amount of tokens operator has access to.",operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1."}}},"0x65aeaa95":{sig:"authorizedAmountFor(address,address)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"}],name:"authorizedAmountFor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners.",params:{operator:"The operator's address to query the authorized amount for.",tokenOwner:"The token owner that `operator` has allowance on."},returns:{_0:"The amount of tokens the `operator`'s address has access on the `tokenOwner`'s balance."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of tokens owned by `tokenOwner`. If the token is divisible (the {decimals} function returns `18`), the amount returned should be divided by 1e18 to get a better picture of the actual balance of the `tokenOwner`. _Example:_ ``` balanceOf(someAddress) -> 42_000_000_000_000_000_000 / 1e18 = 42 tokens ```",params:{tokenOwner:"The address of the token holder to query the balance for."},returns:{_0:"The amount of tokens owned by `tokenOwner`."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x313ce567":{sig:"decimals()",inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of decimals used to get its user representation. If the asset contract has been set to be non-divisible via the `isNonDivisible_` parameter in the `constructor`, the decimals returned will be `0`. Otherwise `18` is the common value.",returns:{_0:"the number of decimals. If `0` is returned, the asset is non-divisible."}}},"0x78381670":{sig:"decreaseAllowance(address,address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"uint256",name:"subtractedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"decreaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The operator to decrease allowance for `msg.sender`",subtractedAmount:"The amount to decrease by in the operator's allowance.",tokenOwner:"The address of the token owner."}},userdoc:{notice:"Decrease the allowance of `operator` by -`subtractedAmount`"}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0xd72fc29a":{sig:"getOperatorsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn on behalf of `tokenOwner`.",params:{tokenOwner:"The token owner to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn tokens on behalf of `tokenOwner`."}}},"0x2bc1da82":{sig:"increaseAllowance(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"addedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"increaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{addedAmount:"The additional amount to add on top of the current operator's allowance",operator:"The operator to increase the allowance for `msg.sender`"}},userdoc:{notice:"Increase the allowance of `operator` by +`addedAmount`"}},"0x7580d920":{sig:"mint(address,uint256,bool,bytes)",inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Public {_mint} function only callable by the {owner}."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0x30d0dc37":{sig:"revokeOperator(address,address,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Enables `tokenOwner` to remove `operator` for its tokens, disallowing it to send any amount of tokens on its behalf. This function also allows the `operator` to remove itself if it is the caller of this function",params:{notify:"Boolean indicating whether to notify the operator or not.",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenOwner:"The address of the token owner."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x760d9bba":{sig:"transfer(address,address,uint256,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers an `amount` of tokens from the `from` address to the `to` address and notify both sender and recipients via the LSP1 {`universalReceiver(...)`} function. If the tokens are transferred by an operator on behalf of a token holder, the allowance for the operator will be decreased by `amount` once the token transfer has been completed (See {authorizedAmountFor}).",params:{amount:"The amount of tokens to transfer.",data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The sender address.",to:"The recipient address."}}},"0x2d7667c9":{sig:"transferBatch(address[],address[],uint256[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"uint256[]",name:"amount",type:"uint256[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Same as {`transfer(...)`} but transfer multiple tokens based on the arrays of `from`, `to`, `amount`.",params:{amount:"An array of amount of tokens to transfer for each `from -> to` transfer.",data:"An array of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",force:"For each transfer, when set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"An array of sending addresses.",to:"An array of receiving addresses."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP7MintableInit:{"0xb49506fd":{sig:"authorizeOperator(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to use the {increaseAllowance} and {decreaseAllowance} functions. For more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",details:"Sets an `amount` of tokens that an `operator` has access from the caller's balance (allowance). See {authorizedAmountFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{amount:"The allowance amount of tokens operator has access to.",operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1."}}},"0x65aeaa95":{sig:"authorizedAmountFor(address,address)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"}],name:"authorizedAmountFor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners.",params:{operator:"The operator's address to query the authorized amount for.",tokenOwner:"The token owner that `operator` has allowance on."},returns:{_0:"The amount of tokens the `operator`'s address has access on the `tokenOwner`'s balance."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of tokens owned by `tokenOwner`. If the token is divisible (the {decimals} function returns `18`), the amount returned should be divided by 1e18 to get a better picture of the actual balance of the `tokenOwner`. _Example:_ ``` balanceOf(someAddress) -> 42_000_000_000_000_000_000 / 1e18 = 42 tokens ```",params:{tokenOwner:"The address of the token holder to query the balance for."},returns:{_0:"The amount of tokens owned by `tokenOwner`."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x313ce567":{sig:"decimals()",inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of decimals used to get its user representation. If the asset contract has been set to be non-divisible via the `isNonDivisible_` parameter in the `constructor`, the decimals returned will be `0`. Otherwise `18` is the common value.",returns:{_0:"the number of decimals. If `0` is returned, the asset is non-divisible."}}},"0x78381670":{sig:"decreaseAllowance(address,address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"uint256",name:"subtractedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"decreaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The operator to decrease allowance for `msg.sender`",subtractedAmount:"The amount to decrease by in the operator's allowance.",tokenOwner:"The address of the token owner."}},userdoc:{notice:"Decrease the allowance of `operator` by -`subtractedAmount`"}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0xd72fc29a":{sig:"getOperatorsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn on behalf of `tokenOwner`.",params:{tokenOwner:"The token owner to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn tokens on behalf of `tokenOwner`."}}},"0x2bc1da82":{sig:"increaseAllowance(address,uint256,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"addedAmount",type:"uint256"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"increaseAllowance",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",params:{addedAmount:"The additional amount to add on top of the current operator's allowance",operator:"The operator to increase the allowance for `msg.sender`"}},userdoc:{notice:"Increase the allowance of `operator` by +`addedAmount`"}},"0x04689a81":{sig:"initialize(string,string,address,uint256,bool)",inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"},{internalType:"address",name:"newOwner_",type:"address"},{internalType:"uint256",name:"lsp4TokenType_",type:"uint256"},{internalType:"bool",name:"isNonDivisible_",type:"bool"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{isNonDivisible_:"Specify if the LSP7 token is a fungible or non-fungible token.",lsp4TokenType_:"The type of token this digital asset contract represents (`0` = Token, `1` = NFT, `2` = Collection).",name_:"The name of the token.",newOwner_:"The owner of the token contract.",symbol_:"The symbol of the token."}},userdoc:{notice:"Initializing a `LSP7MintableInit` token contract with: token name = `name_`, token symbol = `symbol_`, and address `newOwner_` as the token contract owner."}},"0x7580d920":{sig:"mint(address,uint256,bool,bytes)",inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Public {_mint} function only callable by the {owner}."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0x30d0dc37":{sig:"revokeOperator(address,address,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"tokenOwner",type:"address"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Enables `tokenOwner` to remove `operator` for its tokens, disallowing it to send any amount of tokens on its behalf. This function also allows the `operator` to remove itself if it is the caller of this function",params:{notify:"Boolean indicating whether to notify the operator or not.",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenOwner:"The address of the token owner."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x760d9bba":{sig:"transfer(address,address,uint256,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers an `amount` of tokens from the `from` address to the `to` address and notify both sender and recipients via the LSP1 {`universalReceiver(...)`} function. If the tokens are transferred by an operator on behalf of a token holder, the allowance for the operator will be decreased by `amount` once the token transfer has been completed (See {authorizedAmountFor}).",params:{amount:"The amount of tokens to transfer.",data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The sender address.",to:"The recipient address."}}},"0x2d7667c9":{sig:"transferBatch(address[],address[],uint256[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"uint256[]",name:"amount",type:"uint256[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Same as {`transfer(...)`} but transfer multiple tokens based on the arrays of `from`, `to`, `amount`.",params:{amount:"An array of amount of tokens to transfer for each `from -> to` transfer.",data:"An array of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",force:"For each transfer, when set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"An array of sending addresses.",to:"An array of receiving addresses."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8IdentifiableDigitalAsset:{"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8IdentifiableDigitalAssetInitAbstract:{"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8Burnable:{"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x6c79b70b":{sig:"burn(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"data",type:"bytes"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"See internal {_burn} function for details.",params:{data:"Any extra data to be sent alongside burning the tokenId.",tokenId:"The tokenId to burn."}},userdoc:{notice:"Burning tokenId `tokenId`. This tokenId will not be recoverable! (additional data sent: `data`)."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8BurnableInitAbstract:{"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x6c79b70b":{sig:"burn(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"data",type:"bytes"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function"},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8CappedSupply:{"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x52058d8a":{sig:"tokenSupplyCap()",inputs:[],name:"tokenSupplyCap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the maximum number of tokens that can exist to circulate. Once {totalSupply} reaches reaches {totalSupplyCap}, it is not possible to mint more tokens.",returns:{_0:"The maximum number of tokens that can exist in the contract."}},userdoc:{notice:"The maximum supply amount of tokens allowed to exist is `_TOKEN_SUPPLY_CAP`."}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8CappedSupplyInitAbstract:{"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x52058d8a":{sig:"tokenSupplyCap()",inputs:[],name:"tokenSupplyCap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the maximum number of tokens that can exist to circulate. Once {totalSupply} reaches reaches {totalSupplyCap}, it is not possible to mint more tokens.",returns:{_0:"The maximum number of tokens that can exist in the contract."}},userdoc:{notice:"The maximum supply amount of tokens allowed to exist is `_tokenSupplyCap`."}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8Enumerable:{"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0x92a91a3a":{sig:"tokenAt(uint256)",inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenAt",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",devdoc:{details:"Returns a token id at index. See {totalSupply} to get total number of minted tokens.",params:{index:"The index to search to search in the enumerable mapping."},returns:{_0:"TokenId or `bytes32(0)` if no tokenId exist at `index`."}},userdoc:{notice:"Retrieving the `tokenId` for `msg.sender` located in its list at index number `index`."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8EnumerableInitAbstract:{"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0x92a91a3a":{sig:"tokenAt(uint256)",inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenAt",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",devdoc:{details:"Returns a token id at index. See {totalSupply} to get total number of minted tokens.",params:{index:"The index to search to search in the enumerable mapping."},returns:{_0:"TokenId or `bytes32(0)` if no tokenId exist at `index`."}},userdoc:{notice:"Retrieving the `tokenId` for `msg.sender` located in its list at index number `index`."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8Votes:{"0x4bf5d7e9":{sig:"CLOCK_MODE()",inputs:[],name:"CLOCK_MODE",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",devdoc:{details:"Machine-readable description of the clock as specified in EIP-6372."}},"0x3644e515":{sig:"DOMAIN_SEPARATOR()",inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the contract's {EIP712} domain separator."}},"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x91ddadf4":{sig:"clock()",inputs:[],name:"clock",outputs:[{internalType:"uint48",name:"",type:"uint48"}],stateMutability:"view",type:"function",devdoc:{details:"Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match."}},"0x5c19a95c":{sig:"delegate(address)",inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegate",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Delegates votes from the sender to `delegatee`."}},"0xc3cda520":{sig:"delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)",inputs:[{internalType:"address",name:"delegatee",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"delegateBySig",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Delegates votes from signer to `delegatee`."}},"0x587cde1e":{sig:"delegates(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"delegates",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the delegate that `account` has chosen."}},"0x84b0196e":{sig:"eip712Domain()",inputs:[],name:"eip712Domain",outputs:[{internalType:"bytes1",name:"fields",type:"bytes1"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"version",type:"string"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"verifyingContract",type:"address"},{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256[]",name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function",devdoc:{details:"See {EIP-5267}. _Available since v4.9._"}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x8e539e8c":{sig:"getPastTotalSupply(uint256)",inputs:[{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastTotalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the total supply of votes available at a specific moment in the past. If the `clock()` is configured to use block numbers, this will return the value at the end of the corresponding block. NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes. Votes that have not been delegated are still part of total supply, even though they would not participate in a vote. Requirements: - `timepoint` must be in the past. If operating using block numbers, the block must be already mined."}},"0x3a46b1a8":{sig:"getPastVotes(address,uint256)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is configured to use block numbers, this will return the value at the end of the corresponding block. Requirements: - `timepoint` must be in the past. If operating using block numbers, the block must be already mined."}},"0x9ab24eb0":{sig:"getVotes(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"getVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the current amount of votes that `account` has."}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0x7ecebe00":{sig:"nonces(address)",inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns an address nonce."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8VotesInitAbstract:{"0x4bf5d7e9":{sig:"CLOCK_MODE()",inputs:[],name:"CLOCK_MODE",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",devdoc:{details:"Machine-readable description of the clock as specified in EIP-6372."}},"0x3644e515":{sig:"DOMAIN_SEPARATOR()",inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the contract's {EIP712} domain separator."}},"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x91ddadf4":{sig:"clock()",inputs:[],name:"clock",outputs:[{internalType:"uint48",name:"",type:"uint48"}],stateMutability:"view",type:"function",devdoc:{details:"Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match."}},"0x5c19a95c":{sig:"delegate(address)",inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegate",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Delegates votes from the sender to `delegatee`."}},"0xc3cda520":{sig:"delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)",inputs:[{internalType:"address",name:"delegatee",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"delegateBySig",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Delegates votes from signer to `delegatee`."}},"0x587cde1e":{sig:"delegates(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"delegates",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the delegate that `account` has chosen."}},"0x84b0196e":{sig:"eip712Domain()",inputs:[],name:"eip712Domain",outputs:[{internalType:"bytes1",name:"fields",type:"bytes1"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"version",type:"string"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"verifyingContract",type:"address"},{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256[]",name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function",devdoc:{details:"See {EIP-5267}. _Available since v4.9._"}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x8e539e8c":{sig:"getPastTotalSupply(uint256)",inputs:[{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastTotalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the total supply of votes available at a specific moment in the past. If the `clock()` is configured to use block numbers, this will return the value at the end of the corresponding block. NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes. Votes that have not been delegated are still part of total supply, even though they would not participate in a vote. Requirements: - `timepoint` must be in the past. If operating using block numbers, the block must be already mined."}},"0x3a46b1a8":{sig:"getPastVotes(address,uint256)",inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is configured to use block numbers, this will return the value at the end of the corresponding block. Requirements: - `timepoint` must be in the past. If operating using block numbers, the block must be already mined."}},"0x9ab24eb0":{sig:"getVotes(address)",inputs:[{internalType:"address",name:"account",type:"address"}],name:"getVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the current amount of votes that `account` has."}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0x7ecebe00":{sig:"nonces(address)",inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns an address nonce."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8Mintable:{"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0xaf255b61":{sig:"mint(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Public {_mint} function only callable by the {owner}.",params:{data:"Any addition data to be sent alongside the minting.",force:"Set to `false` to ensure that you are minting for a recipient that implements LSP1, `false` otherwise for forcing the minting.",to:"The address that will receive the minted `tokenId`.",tokenId:"The tokenId to mint."}},userdoc:{notice:"Minting tokenId `tokenId` for address `to` with the additional data `data` (Note: allow non-LSP1 recipient is set to `force`)."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP8MintableInit:{"0x86a10ddd":{sig:"authorizeOperator(address,bytes32,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"authorizeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",params:{operator:"The address to authorize as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The token ID operator has access to."}}},"0x70a08231":{sig:"balanceOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Get the number of token IDs owned by `tokenOwner`.",params:{tokenOwner:"The address to query     *"},returns:{_0:"The total number of token IDs that `tokenOwner` owns."}}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1d26fce6":{sig:"getDataBatchForTokenIds(bytes32[],bytes32[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatchForTokenIds",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",tokenIds:"An array of token IDs."},returns:{dataValues:"An array of data values for each pair of `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."}},"0x16e023b3":{sig:"getDataForTokenId(bytes32,bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getDataForTokenId",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{params:{dataKey:"The key for the data to retrieve.",tokenId:"The unique identifier for a token."},returns:{dataValue:"The data value associated with the given `tokenId` and `dataKey`."}},userdoc:{notice:"Retrieves data for a specific `tokenId` and `dataKey`."}},"0x49a6078d":{sig:"getOperatorsOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"getOperatorsOf",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",params:{tokenId:"The token ID to get the operators for."},returns:{_0:"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}}},"0x74823132":{sig:"initialize(string,string,address,uint256,uint256)",inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"},{internalType:"address",name:"newOwner_",type:"address"},{internalType:"uint256",name:"lsp4TokenType_",type:"uint256"},{internalType:"uint256",name:"lsp8TokenIdFormat_",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{lsp4TokenType_:"The type of token this digital asset contract represents (`0` = Token, `1` = NFT, `2` = Collection).",lsp8TokenIdFormat_:"The format of tokenIds (= NFTs) that this contract will create.",name_:"The name of the token.",newOwner_:"The owner of the token contract.",symbol_:"The symbol of the token."}},userdoc:{notice:"Initializing a `LSP8MintableInit` token contract with: token name = `name_`, token symbol = `symbol_`, and address `newOwner_` as the token contract owner."}},"0x2a3654a4":{sig:"isOperatorFor(address,bytes32)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"isOperatorFor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Returns whether `operator` address is an operator for a given `tokenId`.",params:{operator:"The address to query operator status for.",tokenId:"The token ID to check if `operator` is allowed to operate on."},returns:{_0:"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}}},"0xaf255b61":{sig:"mint(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Public {_mint} function only callable by the {owner}.",params:{data:"Any addition data to be sent alongside the minting.",force:"Set to `false` to ensure that you are minting for a recipient that implements LSP1, `false` otherwise for forcing the minting.",to:"The address that will receive the minted `tokenId`.",tokenId:"The tokenId to mint."}},userdoc:{notice:"Minting tokenId `tokenId` for address `to` with the additional data `data` (Note: allow non-LSP1 recipient is set to `force`)."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."}},"0xdb8c9663":{sig:"revokeOperator(address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"notify",type:"bool"},{internalType:"bytes",name:"operatorNotificationData",type:"bytes"}],name:"revokeOperator",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",params:{notify:"Boolean indicating whether to notify the operator or not",operator:"The address to revoke as an operator.",operatorNotificationData:"The data to notify the operator about via LSP1.",tokenId:"The tokenId `operator` is revoked from operating on."}}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event.","custom:requirements":"- SHOULD only be callable by the {owner}.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"{DataChanged} event **for each data key/value pair set**.","custom:requirements":"- SHOULD only be callable by the {owner} of the contract.","custom:warning":"**Note for developers:** despite the fact that this function is set as `payable`, the function is not intended to receive value (= native tokens). **An additional check has been implemented to ensure that `msg.value` sent was equal to 0**. If you want to allow this function to receive value in your inheriting contract, this function can be overriden to remove this check.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0xbe9f0e6f":{sig:"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"tokenIds",type:"bytes32[]"},{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatchForTokenIds",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKeys:"An array of data keys corresponding to the token IDs.",dataValues:"An array of values to set for the given data keys.",tokenIds:"An array of token IDs."}},userdoc:{notice:"Sets data in batch for multiple `tokenId` and `dataKey` pairs."}},"0xd6c1407c":{sig:"setDataForTokenId(bytes32,bytes32,bytes)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setDataForTokenId",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{params:{dataKey:"The key for the data to set.",dataValue:"The value to set for the given data key.",tokenId:"The unique identifier for a token."}},userdoc:{notice:"Sets data for a specific `tokenId` and `dataKey`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"See {IERC165-supportsInterface}."}},"0xa3b261f2":{sig:"tokenIdsOf(address)",inputs:[{internalType:"address",name:"tokenOwner",type:"address"}],name:"tokenIdsOf",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the list of token IDs that the `tokenOwner` address owns.",params:{tokenOwner:"The address that we want to get the list of token IDs for."},returns:{_0:"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}}},"0x217b2270":{sig:"tokenOwnerOf(bytes32)",inputs:[{internalType:"bytes32",name:"tokenId",type:"bytes32"}],name:"tokenOwnerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address that owns a given `tokenId`.",params:{tokenId:"The token ID to query the owner for."},returns:{_0:"The owner address of the given `tokenId`."}}},"0x18160ddd":{sig:"totalSupply()",inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the number of existing tokens that have been minted in this contract.",returns:{_0:"The number of existing tokens."}}},"0x511b6952":{sig:"transfer(address,address,bytes32,bool,bytes)",inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes32",name:"tokenId",type:"bytes32"},{internalType:"bool",name:"force",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",force:"When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",from:"The address that owns the given `tokenId`.",to:"The address that will receive the `tokenId`.",tokenId:"The token ID to transfer."}}},"0x7e87632c":{sig:"transferBatch(address[],address[],bytes32[],bool[],bytes[])",inputs:[{internalType:"address[]",name:"from",type:"address[]"},{internalType:"address[]",name:"to",type:"address[]"},{internalType:"bytes32[]",name:"tokenId",type:"bytes32[]"},{internalType:"bool[]",name:"force",type:"bool[]"},{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"transferBatch",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",params:{data:"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",force:"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",from:"An array of sending addresses.",to:"An array of recipient addresses.",tokenId:"An array of token IDs to transfer."}}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},LSP9Vault:{"0xead3fbdf":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0x01bfba61":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0xffa1ad74":{sig:"VERSION()",inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",userdoc:{notice:"Contract version."}},"0x79ba5097":{sig:"acceptOwnership()",inputs:[],name:"acceptOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Only the {pendingOwner} can call this function. - When notifying the previous owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_SenderNotification]. - When notifying the new owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_RecipientNotification].",details:"Transfer ownership of the contract from the current {owner()} to the {pendingOwner()}. Once this function is called: - The current {owner()} will lose access to the functions restricted to the {owner()} only. - The {pendingOwner()} will gain access to the functions restricted to the {owner()} only."},userdoc:{notice:"`msg.sender` is accepting ownership of contract: `address(this)`."}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x44c028fe":{sig:"execute(uint256,address,uint256,bytes)",inputs:[{internalType:"uint256",name:"operationType",type:"uint256"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"execute",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0) and `STATICCALL` (3). - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2). - {UniversalReceiver} event when receiving native tokens.","custom:info":"The `operationType` 4 `DELEGATECALL` is disabled by default in the LSP9 Vault.","custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3), `value` transfer is disallowed and must be 0.",details:"Generic executor function to: - send native tokens to any address. - interact with any contract by passing an abi-encoded function call in the `data` parameter. - deploy a contract by providing its creation bytecode in the `data` parameter.",params:{data:"The call data, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationType:"The operation type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",target:"The address of the EOA or smart contract.  (unused if a contract is created via operation type 1 or 2)",value:"The amount of native tokens to transfer (in Wei)"}},userdoc:{notice:"Calling address `target` using `operationType`, transferring `value` wei and data: `data`."}},"0x31858452":{sig:"executeBatch(uint256[],address[],uint256[],bytes[])",inputs:[{internalType:"uint256[]",name:"operationsType",type:"uint256[]"},{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"datas",type:"bytes[]"}],name:"executeBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0) and `STATICCALL` (3). (each iteration) - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2). (each iteration) - {UniversalReceiver} event when receiving native tokens.","custom:info":"The `operationType` 4 `DELEGATECALL` is disabled by default in the LSP9 Vault.","custom:requirements":"- The length of the parameters provided must be equal. - Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3), `value` transfer is disallowed and must be 0.",details:"Batch executor function that behaves the same as {execute} but allowing multiple operations in the same transaction.",params:{datas:"The list of calldata, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationsType:"The list of operations type used: `CALL = 0`; `CREATE = 1`; `CREATE2 = 2`; `STATICCALL = 3`; `DELEGATECALL = 4`",targets:"The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",values:"The list of native token amounts to transfer (in Wei)."}},userdoc:{notice:"Calling multiple addresses `targets` using `operationsType`, transferring `values` wei and data: `datas`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0xe30c3978":{sig:"pendingOwner()",inputs:[],name:"pendingOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{"custom:info":"If no ownership transfer is in progress, the pendingOwner will be `address(0).`.",details:"The address that ownership of the contract is transferred to. This address may use {acceptOwnership()} to gain ownership of the contract."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"Leaves the contract without an owner. Once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Renounce ownership of the contract in a 2-step process. 1. The first call will initiate the process of renouncing ownership. 2. The second call is used as a confirmation and will leave the contract without an owner."},userdoc:{notice:"`msg.sender` is renouncing ownership of contract `address(this)`."}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {DataChanged} event.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {DataChanged} event. (on each iteration of setting data)","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Achieves the goal of [ERC-165] to detect supported interfaces and [LSP-17-ContractExtension] by checking if the interfaceId being queried is supported on another linked extension. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to [LSP-17-ContractExtension], and checks if the extension implements the interface defined by `interfaceId`.",params:{interfaceId:"The interface ID to check if the contract supports it."},returns:{_0:"`true` if this contract implements the interface defined by `interfaceId`, `false` otherwise."}},userdoc:{notice:"Checking if this contract supports the interface defined by the `bytes4` interface ID `interfaceId`."}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - When notifying the new owner via LSP1, the `typeId` used must be the `keccak256(...)` hash of [LSP0OwnershipTransferStarted]. - Pending owner cannot accept ownership in the same tx via the LSP1 hook.",details:"Initiate the process of transferring ownership of the contract by setting the new owner as the pending owner. If the new owner is a contract that supports + implements LSP1, this will also attempt to notify the new owner that ownership has been transferred to them by calling the {universalReceiver()} function on the `newOwner` contract.",params:{newOwner:"The address of the new owner."}},userdoc:{notice:"Transfer ownership initiated by `newOwner`."}},"0x6bb56a14":{sig:"universalReceiver(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"typeId",type:"bytes32"},{internalType:"bytes",name:"receivedData",type:"bytes"}],name:"universalReceiver",outputs:[{internalType:"bytes",name:"returnedValues",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract that was called.",details:"Achieves the goal of [LSP-1-UniversalReceiver] by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts ([LSP1UniversalReceiverDelegate]) that react on the whole transaction and on the specific typeId, respectively. The function performs the following steps: 1. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY].      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. 2. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX] + `bytes32(typeId)`.   (Check [LSP-2-ERC725YJSONSchema] for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function.",params:{receivedData:"The data received.",typeId:"The type of call received."},returns:{returnedValues:"The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call."}},userdoc:{notice:"Notifying the contract by calling its `universalReceiver` function with the following information: typeId: `typeId`; data: `data`."}}},LSP9VaultInit:{"0xead3fbdf":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0x01bfba61":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0xffa1ad74":{sig:"VERSION()",inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",userdoc:{notice:"Contract version."}},"0x79ba5097":{sig:"acceptOwnership()",inputs:[],name:"acceptOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Only the {pendingOwner} can call this function. - When notifying the previous owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_SenderNotification]. - When notifying the new owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_RecipientNotification].",details:"Transfer ownership of the contract from the current {owner()} to the {pendingOwner()}. Once this function is called: - The current {owner()} will lose access to the functions restricted to the {owner()} only. - The {pendingOwner()} will gain access to the functions restricted to the {owner()} only."},userdoc:{notice:"`msg.sender` is accepting ownership of contract: `address(this)`."}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x44c028fe":{sig:"execute(uint256,address,uint256,bytes)",inputs:[{internalType:"uint256",name:"operationType",type:"uint256"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"execute",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0) and `STATICCALL` (3). - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2). - {UniversalReceiver} event when receiving native tokens.","custom:info":"The `operationType` 4 `DELEGATECALL` is disabled by default in the LSP9 Vault.","custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3), `value` transfer is disallowed and must be 0.",details:"Generic executor function to: - send native tokens to any address. - interact with any contract by passing an abi-encoded function call in the `data` parameter. - deploy a contract by providing its creation bytecode in the `data` parameter.",params:{data:"The call data, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationType:"The operation type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",target:"The address of the EOA or smart contract.  (unused if a contract is created via operation type 1 or 2)",value:"The amount of native tokens to transfer (in Wei)"}},userdoc:{notice:"Calling address `target` using `operationType`, transferring `value` wei and data: `data`."}},"0x31858452":{sig:"executeBatch(uint256[],address[],uint256[],bytes[])",inputs:[{internalType:"uint256[]",name:"operationsType",type:"uint256[]"},{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"datas",type:"bytes[]"}],name:"executeBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0) and `STATICCALL` (3). (each iteration) - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2). (each iteration) - {UniversalReceiver} event when receiving native tokens.","custom:info":"The `operationType` 4 `DELEGATECALL` is disabled by default in the LSP9 Vault.","custom:requirements":"- The length of the parameters provided must be equal. - Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3), `value` transfer is disallowed and must be 0.",details:"Batch executor function that behaves the same as {execute} but allowing multiple operations in the same transaction.",params:{datas:"The list of calldata, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationsType:"The list of operations type used: `CALL = 0`; `CREATE = 1`; `CREATE2 = 2`; `STATICCALL = 3`; `DELEGATECALL = 4`",targets:"The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",values:"The list of native token amounts to transfer (in Wei)."}},userdoc:{notice:"Calling multiple addresses `targets` using `operationsType`, transferring `values` wei and data: `datas`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0xc4d66de8":{sig:"initialize(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"initialize",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event when funding the contract on deployment. - {OwnershipTransferred} event when `initialOwner` is set as the contract {owner}. - {DataChanged} event when updating the {_LSP9_SUPPORTED_STANDARDS_KEY}. - {UniversalReceiver} event when notifying the `initialOwner`.",details:"Sets `initialOwner` as the contract owner and the `SupportedStandards:LSP9Vault` Data Key. The `initialize(address)` also allows funding the contract on deployment.",params:{newOwner:"The new owner of the contract."}},userdoc:{notice:"Initializing a LSP9Vault contract with owner set to address `initialOwner`."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0xe30c3978":{sig:"pendingOwner()",inputs:[],name:"pendingOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{"custom:info":"If no ownership transfer is in progress, the pendingOwner will be `address(0).`.",details:"The address that ownership of the contract is transferred to. This address may use {acceptOwnership()} to gain ownership of the contract."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"Leaves the contract without an owner. Once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Renounce ownership of the contract in a 2-step process. 1. The first call will initiate the process of renouncing ownership. 2. The second call is used as a confirmation and will leave the contract without an owner."},userdoc:{notice:"`msg.sender` is renouncing ownership of contract `address(this)`."}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {DataChanged} event.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {DataChanged} event. (on each iteration of setting data)","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Achieves the goal of [ERC-165] to detect supported interfaces and [LSP-17-ContractExtension] by checking if the interfaceId being queried is supported on another linked extension. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to [LSP-17-ContractExtension], and checks if the extension implements the interface defined by `interfaceId`.",params:{interfaceId:"The interface ID to check if the contract supports it."},returns:{_0:"`true` if this contract implements the interface defined by `interfaceId`, `false` otherwise."}},userdoc:{notice:"Checking if this contract supports the interface defined by the `bytes4` interface ID `interfaceId`."}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - When notifying the new owner via LSP1, the `typeId` used must be the `keccak256(...)` hash of [LSP0OwnershipTransferStarted]. - Pending owner cannot accept ownership in the same tx via the LSP1 hook.",details:"Initiate the process of transferring ownership of the contract by setting the new owner as the pending owner. If the new owner is a contract that supports + implements LSP1, this will also attempt to notify the new owner that ownership has been transferred to them by calling the {universalReceiver()} function on the `newOwner` contract.",params:{newOwner:"The address of the new owner."}},userdoc:{notice:"Transfer ownership initiated by `newOwner`."}},"0x6bb56a14":{sig:"universalReceiver(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"typeId",type:"bytes32"},{internalType:"bytes",name:"receivedData",type:"bytes"}],name:"universalReceiver",outputs:[{internalType:"bytes",name:"returnedValues",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract that was called.",details:"Achieves the goal of [LSP-1-UniversalReceiver] by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts ([LSP1UniversalReceiverDelegate]) that react on the whole transaction and on the specific typeId, respectively. The function performs the following steps: 1. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY].      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. 2. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX] + `bytes32(typeId)`.   (Check [LSP-2-ERC725YJSONSchema] for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function.",params:{receivedData:"The data received.",typeId:"The type of call received."},returns:{returnedValues:"The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call."}},userdoc:{notice:"Notifying the contract by calling its `universalReceiver` function with the following information: typeId: `typeId`; data: `data`."}}},UniversalProfile:{"0xead3fbdf":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0x01bfba61":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0xffa1ad74":{sig:"VERSION()",inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",userdoc:{notice:"Contract version."}},"0x79ba5097":{sig:"acceptOwnership()",inputs:[],name:"acceptOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Only the {pendingOwner} can call this function. - When notifying the previous owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_SenderNotification]. - When notifying the new owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_RecipientNotification].",details:"Transfer ownership of the contract from the current {owner()} to the {pendingOwner()}. Once this function is called: - The current {owner()} will lose access to the functions restricted to the {owner()} only. - The {pendingOwner()} will gain access to the functions restricted to the {owner()} only."},userdoc:{notice:"`msg.sender` is accepting ownership of contract: `address(this)`."}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x44c028fe":{sig:"execute(uint256,address,uint256,bytes)",inputs:[{internalType:"uint256",name:"operationType",type:"uint256"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"execute",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0), `STATICCALL` (3) and `DELEGATECALL` (4). - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2). - {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens.","custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3) or `DELEGATECALL` (4), `value` transfer is disallowed and must be 0.",details:"Generic executor function to: - send native tokens to any address. - interact with any contract by passing an abi-encoded function call in the `data` parameter. - deploy a contract by providing its creation bytecode in the `data` parameter.",params:{data:"The call data, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationType:"The operation type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",target:"The address of the EOA or smart contract.  (unused if a contract is created via operation type 1 or 2)",value:"The amount of native tokens to transfer (in Wei)"}},userdoc:{notice:"Calling address `target` using `operationType`, transferring `value` wei and data: `data`."}},"0x31858452":{sig:"executeBatch(uint256[],address[],uint256[],bytes[])",inputs:[{internalType:"uint256[]",name:"operationsType",type:"uint256[]"},{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"datas",type:"bytes[]"}],name:"executeBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0), `STATICCALL` (3) and `DELEGATECALL` (4). (each iteration) - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2) (each iteration) - {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens.","custom:requirements":"- The length of the parameters provided must be equal. - Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3) or `DELEGATECALL` (4), `value` transfer is disallowed and must be 0.","custom:warning":"- The `msg.value` should not be trusted for any method called within the batch with `operationType`: `DELEGATECALL` (4).",details:"Batch executor function that behaves the same as {execute} but allowing multiple operations in the same transaction.",params:{datas:"The list of calldata, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationsType:"The list of operations type used: `CALL = 0`; `CREATE = 1`; `CREATE2 = 2`; `STATICCALL = 3`; `DELEGATECALL = 4`",targets:"The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",values:"The list of native token amounts to transfer (in Wei)."}},userdoc:{notice:"Calling multiple addresses `targets` using `operationsType`, transferring `values` wei and data: `datas`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0x1626ba7e":{sig:"isValidSignature(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataHash",type:"bytes32"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"isValidSignature",outputs:[{internalType:"bytes4",name:"returnedStatus",type:"bytes4"}],stateMutability:"view",type:"function",devdoc:{"custom:warning":"This function does not enforce by default the inclusion of the address of this contract in the signature digest. It is recommended that protocols or applications using this contract include the targeted address (= this contract) in the data to sign. To ensure that a signature is valid for a specific LSP0ERC725Account and prevent signatures from the same EOA to be replayed across different LSP0ERC725Accounts.",details:"Handles two cases: 1. If the owner is an EOA, recovers an address from the hash and the signature provided:      - Returns the `_ERC1271_SUCCESSVALUE` if the address recovered is the same as the owner, indicating that it was a valid signature.      - If the address is different, it returns the `_ERC1271_FAILVALUE` indicating that the signature is not valid. 2. If the owner is a smart contract, it forwards the call of {isValidSignature()} to the owner contract:      - If the contract fails or returns the `_ERC1271_FAILVALUE`, the {isValidSignature()} on the account returns the `_ERC1271_FAILVALUE`, indicating that the signature is not valid.      - If the {isValidSignature()} on the owner returned the `_ERC1271_SUCCESSVALUE`, the {isValidSignature()} on the account returns the `_ERC1271_SUCCESSVALUE`, indicating that it's a valid signature.",params:{dataHash:"The hash of the data to be validated.",signature:"A signature that can validate the previous parameter (Hash)."},returns:{returnedStatus:"A `bytes4` value that indicates if the signature is valid or not."}},userdoc:{notice:"Achieves the goal of [EIP-1271] by validating signatures of smart contracts according to their own logic."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0xe30c3978":{sig:"pendingOwner()",inputs:[],name:"pendingOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{"custom:info":"If no ownership transfer is in progress, the pendingOwner will be `address(0).`.",details:"The address that ownership of the contract is transferred to. This address may use {acceptOwnership()} to gain ownership of the contract."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"Leaves the contract without an owner. Once ownership of the contract has been renounced, any functions that are restricted to be called by the owner or an address allowed by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Renounce ownership of the contract in a 2-step process. 1. The first call will initiate the process of renouncing ownership. 2. The second call is used as a confirmation and will leave the contract without an owner."},userdoc:{notice:"`msg.sender` is renouncing ownership of contract `address(this)`."}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens. - {DataChanged} event.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens. - {DataChanged} event. (on each iteration of setting data)","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Achieves the goal of [ERC-165] to detect supported interfaces and [LSP-17-ContractExtension] by checking if the interfaceId being queried is supported on another linked extension. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to [LSP-17-ContractExtension], and checks if the extension implements the interface defined by `interfaceId`.",params:{interfaceId:"The interface ID to check if the contract supports it."},returns:{_0:"`true` if this contract implements the interface defined by `interfaceId`, `false` otherwise."}},userdoc:{notice:"Checking if this contract supports the interface defined by the `bytes4` interface ID `interfaceId`."}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"pendingNewOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - When notifying the new owner via LSP1, the `typeId` used must be the `keccak256(...)` hash of [LSP0OwnershipTransferStarted]. - Pending owner cannot accept ownership in the same tx via the LSP1 hook.",details:"Initiate the process of transferring ownership of the contract by setting the new owner as the pending owner. If the new owner is a contract that supports + implements LSP1, this will also attempt to notify the new owner that ownership has been transferred to them by calling the {universalReceiver()} function on the `newOwner` contract.",params:{newOwner:"The address of the new owner."}},userdoc:{notice:"Transfer ownership initiated by `newOwner`."}},"0x6bb56a14":{sig:"universalReceiver(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"typeId",type:"bytes32"},{internalType:"bytes",name:"receivedData",type:"bytes"}],name:"universalReceiver",outputs:[{internalType:"bytes",name:"returnedValues",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} with typeId {`LSP0ValueReceived`} when receiving native tokens. - {UniversalReceiver} event with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract that was called.",details:"Achieves the goal of [LSP-1-UniversalReceiver] by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts ([LSP1UniversalReceiverDelegate]) that react on the whole transaction and on the specific typeId, respectively. The function performs the following steps: 1. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY].      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. 2. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX] + `bytes32(typeId)`.   (Check [LSP-2-ERC725YJSONSchema] for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. This function delegates internally the handling of native tokens to the {universalReceiver} function itself passing `_TYPEID_LSP0_VALUE_RECEIVED` as typeId and the calldata as received data.",params:{receivedData:"The data received.",typeId:"The type of call received."},returns:{returnedValues:"The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call."}},userdoc:{notice:"Notifying the contract by calling its `universalReceiver` function with the following information: typeId: `typeId`; data: `data`."}}},UniversalProfileInit:{"0xead3fbdf":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0x01bfba61":{sig:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",inputs:[],name:"RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"0xffa1ad74":{sig:"VERSION()",inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",userdoc:{notice:"Contract version."}},"0x79ba5097":{sig:"acceptOwnership()",inputs:[],name:"acceptOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Only the {pendingOwner} can call this function. - When notifying the previous owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_SenderNotification]. - When notifying the new owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_RecipientNotification].",details:"Transfer ownership of the contract from the current {owner()} to the {pendingOwner()}. Once this function is called: - The current {owner()} will lose access to the functions restricted to the {owner()} only. - The {pendingOwner()} will gain access to the functions restricted to the {owner()} only."},userdoc:{notice:"`msg.sender` is accepting ownership of contract: `address(this)`."}},"0x6963d438":{sig:"batchCalls(bytes[])",inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"batchCalls",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function",devdoc:{"custom:info":"It's not possible to send value along the functions call due to the use of `delegatecall`.",details:"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",params:{data:"An array of ABI encoded function calls to be called on the contract."},returns:{results:"An array of abi-encoded data returned by the functions executed."}},userdoc:{notice:"Executing the following batch of abi-encoded function calls on the contract: `data`."}},"0x44c028fe":{sig:"execute(uint256,address,uint256,bytes)",inputs:[{internalType:"uint256",name:"operationType",type:"uint256"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"execute",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0), `STATICCALL` (3) and `DELEGATECALL` (4). - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2). - {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens.","custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3) or `DELEGATECALL` (4), `value` transfer is disallowed and must be 0.",details:"Generic executor function to: - send native tokens to any address. - interact with any contract by passing an abi-encoded function call in the `data` parameter. - deploy a contract by providing its creation bytecode in the `data` parameter.",params:{data:"The call data, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationType:"The operation type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",target:"The address of the EOA or smart contract.  (unused if a contract is created via operation type 1 or 2)",value:"The amount of native tokens to transfer (in Wei)"}},userdoc:{notice:"Calling address `target` using `operationType`, transferring `value` wei and data: `data`."}},"0x31858452":{sig:"executeBatch(uint256[],address[],uint256[],bytes[])",inputs:[{internalType:"uint256[]",name:"operationsType",type:"uint256[]"},{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"datas",type:"bytes[]"}],name:"executeBatch",outputs:[{internalType:"bytes[]",name:"",type:"bytes[]"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {Executed} event for each call that uses under `operationType`: `CALL` (0), `STATICCALL` (3) and `DELEGATECALL` (4). (each iteration) - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2) (each iteration) - {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens.","custom:requirements":"- The length of the parameters provided must be equal. - Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3) or `DELEGATECALL` (4), `value` transfer is disallowed and must be 0.","custom:warning":"- The `msg.value` should not be trusted for any method called within the batch with `operationType`: `DELEGATECALL` (4).",details:"Batch executor function that behaves the same as {execute} but allowing multiple operations in the same transaction.",params:{datas:"The list of calldata, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",operationsType:"The list of operations type used: `CALL = 0`; `CREATE = 1`; `CREATE2 = 2`; `STATICCALL = 3`; `DELEGATECALL = 4`",targets:"The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",values:"The list of native token amounts to transfer (in Wei)."}},userdoc:{notice:"Calling multiple addresses `targets` using `operationsType`, transferring `values` wei and data: `datas`."}},"0x54f6127f":{sig:"getData(bytes32)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"}],name:"getData",outputs:[{internalType:"bytes",name:"dataValue",type:"bytes"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",params:{dataKey:"The data key for which to retrieve the value."},returns:{dataValue:"The bytes value stored under the specified data key."}},userdoc:{notice:"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."}},"0xdedff9c6":{sig:"getDataBatch(bytes32[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"}],name:"getDataBatch",outputs:[{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],stateMutability:"view",type:"function",devdoc:{details:"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",params:{dataKeys:"The array of keys which values to retrieve"},returns:{dataValues:"The array of data stored at multiple keys"}},userdoc:{notice:"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."}},"0xc4d66de8":{sig:"initialize(address)",inputs:[{internalType:"address",name:"initialOwner",type:"address"}],name:"initialize",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event when funding the contract on deployment. - {OwnershipTransferred} event when `initialOwner` is set as the contract {owner}. - {DataChanged} event when setting the {_LSP3_SUPPORTED_STANDARDS_KEY}.",details:"Set `initialOwner` as the contract owner and the `SupportedStandards:LSP3Profile` data key in the ERC725Y data key/value store. - The `initialize(address)` function is payable and allows funding the contract on initialization. - The `initialOwner` will then be allowed to call protected functions marked with the `onlyOwner` modifier.",params:{initialOwner:"the owner of the contract"}},userdoc:{notice:"Initializing a UniversalProfile contract with owner set to address `initialOwner`."}},"0x1626ba7e":{sig:"isValidSignature(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataHash",type:"bytes32"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"isValidSignature",outputs:[{internalType:"bytes4",name:"returnedStatus",type:"bytes4"}],stateMutability:"view",type:"function",devdoc:{"custom:warning":"This function does not enforce by default the inclusion of the address of this contract in the signature digest. It is recommended that protocols or applications using this contract include the targeted address (= this contract) in the data to sign. To ensure that a signature is valid for a specific LSP0ERC725Account and prevent signatures from the same EOA to be replayed across different LSP0ERC725Accounts.",details:"Handles two cases: 1. If the owner is an EOA, recovers an address from the hash and the signature provided:      - Returns the `_ERC1271_SUCCESSVALUE` if the address recovered is the same as the owner, indicating that it was a valid signature.      - If the address is different, it returns the `_ERC1271_FAILVALUE` indicating that the signature is not valid. 2. If the owner is a smart contract, it forwards the call of {isValidSignature()} to the owner contract:      - If the contract fails or returns the `_ERC1271_FAILVALUE`, the {isValidSignature()} on the account returns the `_ERC1271_FAILVALUE`, indicating that the signature is not valid.      - If the {isValidSignature()} on the owner returned the `_ERC1271_SUCCESSVALUE`, the {isValidSignature()} on the account returns the `_ERC1271_SUCCESSVALUE`, indicating that it's a valid signature.",params:{dataHash:"The hash of the data to be validated.",signature:"A signature that can validate the previous parameter (Hash)."},returns:{returnedStatus:"A `bytes4` value that indicates if the signature is valid or not."}},userdoc:{notice:"Achieves the goal of [EIP-1271] by validating signatures of smart contracts according to their own logic."}},"0x8da5cb5b":{sig:"owner()",inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{details:"Returns the address of the current owner."}},"0xe30c3978":{sig:"pendingOwner()",inputs:[],name:"pendingOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",devdoc:{"custom:info":"If no ownership transfer is in progress, the pendingOwner will be `address(0).`.",details:"The address that ownership of the contract is transferred to. This address may use {acceptOwnership()} to gain ownership of the contract."}},"0x715018a6":{sig:"renounceOwnership()",inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:danger":"Leaves the contract without an owner. Once ownership of the contract has been renounced, any functions that are restricted to be called by the owner or an address allowed by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Renounce ownership of the contract in a 2-step process. 1. The first call will initiate the process of renouncing ownership. 2. The second call is used as a confirmation and will leave the contract without an owner."},userdoc:{notice:"`msg.sender` is renouncing ownership of contract `address(this)`."}},"0x7f23690c":{sig:"setData(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"dataKey",type:"bytes32"},{internalType:"bytes",name:"dataValue",type:"bytes"}],name:"setData",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens. - {DataChanged} event.","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",params:{dataKey:"The data key for which to set a new value.",dataValue:"The new bytes value to set."}},userdoc:{notice:"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."}},"0x97902421":{sig:"setDataBatch(bytes32[],bytes[])",inputs:[{internalType:"bytes32[]",name:"dataKeys",type:"bytes32[]"},{internalType:"bytes[]",name:"dataValues",type:"bytes[]"}],name:"setDataBatch",outputs:[],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} event with typeId {`LSP0ValueReceived`} when receiving native tokens. - {DataChanged} event. (on each iteration of setting data)","custom:requirements":"Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",details:"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",params:{dataKeys:"An array of data keys to set bytes values for.",dataValues:"An array of bytes values to set for each `dataKeys`."}},userdoc:{notice:"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"0x01ffc9a7":{sig:"supportsInterface(bytes4)",inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",devdoc:{details:"Achieves the goal of [ERC-165] to detect supported interfaces and [LSP-17-ContractExtension] by checking if the interfaceId being queried is supported on another linked extension. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to [LSP-17-ContractExtension], and checks if the extension implements the interface defined by `interfaceId`.",params:{interfaceId:"The interface ID to check if the contract supports it."},returns:{_0:"`true` if this contract implements the interface defined by `interfaceId`, `false` otherwise."}},userdoc:{notice:"Checking if this contract supports the interface defined by the `bytes4` interface ID `interfaceId`."}},"0xf2fde38b":{sig:"transferOwnership(address)",inputs:[{internalType:"address",name:"pendingNewOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",devdoc:{"custom:requirements":"- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - When notifying the new owner via LSP1, the `typeId` used must be the `keccak256(...)` hash of [LSP0OwnershipTransferStarted]. - Pending owner cannot accept ownership in the same tx via the LSP1 hook.",details:"Initiate the process of transferring ownership of the contract by setting the new owner as the pending owner. If the new owner is a contract that supports + implements LSP1, this will also attempt to notify the new owner that ownership has been transferred to them by calling the {universalReceiver()} function on the `newOwner` contract.",params:{newOwner:"The address of the new owner."}},userdoc:{notice:"Transfer ownership initiated by `newOwner`."}},"0x6bb56a14":{sig:"universalReceiver(bytes32,bytes)",inputs:[{internalType:"bytes32",name:"typeId",type:"bytes32"},{internalType:"bytes",name:"receivedData",type:"bytes"}],name:"universalReceiver",outputs:[{internalType:"bytes",name:"returnedValues",type:"bytes"}],stateMutability:"payable",type:"function",devdoc:{"custom:events":"- {UniversalReceiver} with typeId {`LSP0ValueReceived`} when receiving native tokens. - {UniversalReceiver} event with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract that was called.",details:"Achieves the goal of [LSP-1-UniversalReceiver] by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts ([LSP1UniversalReceiverDelegate]) that react on the whole transaction and on the specific typeId, respectively. The function performs the following steps: 1. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY].      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. 2. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX] + `bytes32(typeId)`.   (Check [LSP-2-ERC725YJSONSchema] for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. This function delegates internally the handling of native tokens to the {universalReceiver} function itself passing `_TYPEID_LSP0_VALUE_RECEIVED` as typeId and the calldata as received data.",params:{receivedData:"The data received.",typeId:"The type of call received."},returns:{returnedValues:"The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call."}},userdoc:{notice:"Notifying the contract by calling its `universalReceiver` function with the following information: typeId: `typeId`; data: `data`."}}}};m.I,o.lz,u.AO;let k={ERC165:"0x01ffc9a7",ERC1271:"0x1626ba7e",ERC20:"0x36372b07",ERC20Metadata:"0xa219a025",ERC223:"0x87d43052",ERC721:"0x80ac58cd",ERC721Metadata:"0x5b5e139f",ERC777:"0xe58e113c",ERC1155:"0xd9b67a26",ERC725X:"0x7545acac",ERC725Y:"0x629aa694",LSP0ERC725Account:n.eE,LSP1UniversalReceiver:y.l,LSP1UniversalReceiverDelegate:c.I,LSP6KeyManager:s.ep,LSP7DigitalAsset:l.ZM,LSP8IdentifiableDigitalAsset:r.s9,LSP9Vault:u.lv,LSP11SocialRecovery:p.q,LSP14Ownable2Step:h.j,LSP17Extendable:f.cx,LSP17Extension:f.N2,LSP20CallVerification:i.v1,LSP20CallVerifier:i.O2,LSP25ExecuteRelayCall:d.H,LSP26FollowerSystem:b.A},I={LSP1:{...y.J},LSP3:{...m.z},LSP4:{...o._U},LSP5:{...v.n},LSP6:{...s.e1},LSP8:{...r.ag},LSP9:{...u.ZP},LSP10:{...g.B},LSP12:{...w.f},LSP17:{...f._g}};({...n.cX,...l.xz,...r.e6,...u.h4,...h.f})}}]);